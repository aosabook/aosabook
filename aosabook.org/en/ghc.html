<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="provenance" content="$Id: ghc.html 1342 2012-04-26 15:40:53Z amy $">
    <link rel="stylesheet" href="../bootstrap/css/bootstrap.css" type="text/css">
    <link rel="stylesheet" href="../bootstrap/css/bootstrap-responsive.css" type="text/css">
    <link rel="stylesheet" href="aosa.css" type="text/css">
    <title>The Architecture of Open Source Applications (Volume 2): The Glasgow Haskell Compiler</title>
  </head>
  <body>

  <div class="container">
    <div class="row-fluid">
      <div class="hero-unit">
        <a class="pull-right" href="index.html"><img src="../images/titlebar2.jpg"
           alt="The Architecture of Open Source Applications (Volume 2)"</img></a>
        <h1>The Glasgow Haskell Compiler</h1>
        <p><a href="intro2.html#marlow-simon">Simon Marlow</a> and <a href="intro2.html#peyton-jones-simon">Simon Peyton-Jones</a></p>
      </div>
    </div>
    <div class="row">
      <div class="span8 offset2">
        
<p>The Glasgow Haskell Compiler (GHC) started as part of an academic
research project funded by the UK government at the beginning of the
1990s, with several goals in mind:</p>

<ul>

<li>
To make freely available a robust and portable compiler for
  Haskell that generates high performance code;
</li>

<li>
To provide a modular foundation that other researchers can
  extend and develop;
</li>

<li>
To learn how real programs behave, so that we can design and
  build better compilers.
</li>

</ul>

<p>GHC is now over 20 years old, and has been under continuous active
development since its inception.  Today, GHC releases are downloaded
by hundreds of thousands of people, the online repository of Haskell
libraries has over 3,000 packages, GHC is used to teach Haskell in many
undergraduate courses, and there are a growing number of instances of
Haskell being depended upon commercially.</p>

<p>Over its lifetime GHC has generally had around two or three active
developers, although the number of people who have contributed some
code to GHC is in the hundreds.  While the ultimate goal for us, the
main developers of GHC, is to produce research rather than code, we
consider developing GHC to be an essential prerequisite: the artifacts
of research are fed back into GHC, so that GHC can then be used as the
basis for further research that builds on these previous ideas.
Moreover, it is important that GHC is an industrial-strength product,
since this gives greater credence to research results produced with
it.  So while GHC is stuffed full of cutting-edge research ideas, a
great deal of effort is put into ensuring that it can be relied on for
production use.  There has often been some tension between these two
seemingly contradictory goals, but by and large we have found a path
that is satisfactory both from the research and the production-use
angles.</p>

<p>In this chapter we want to give an overview of the architecture of
GHC, and focus on a handful of the key ideas that have been successful
in GHC (and a few that haven't).  Hopefully throughout the following
pages you will gain some insight into how we managed to keep a large
software project active for over 20 years without it collapsing under
its own weight, with what is generally considered to be a very small
development team.</p>

<section>
<h2>5.1. What is Haskell?</h2>

<p>Haskell is a functional programming language, defined by a document
known as the "Haskell Report" of which the latest revision is
Haskell 2010 [<a href="bib2.html#haskell2010">Mar10</a>].  Haskell was created in 1990 by
several members of the academic research community interested in
functional languages, to address the lack of a common language that
could be used as a focus for their research.</p>

<p>Two features of Haskell stand out amongst the programming languages
crowd:</p>

<ul>

<li>
It is <em>purely functional</em>.  That is, functions cannot have
  side effects or mutate data; for a given set of inputs (arguments) a
  function always gives the same result.  The benefits of this model
  for reasoning about code (and, we believe, writing code) are clear,
  but integrating input/output into the purely functional setting
  proved to be a significant challenge.  Fortunately an elegant
  solution in the form of <em>monads</em> was discovered, which not only
  allowed input/output to be neatly integrated with purely functional
  code, but introduced a powerful new abstraction that revolutionised
  coding in Haskell (and subsequently had an impact on other languages
  too).
</li>

<li>
It is <em>lazy</em>.  This refers to the evaluation strategy of
  the language: most languages use <em>strict</em> evaluation in which
  the arguments to a function are evaluated before the function is
  called, whereas in Haskell the arguments to a function are passed
</li>
  <em>unevaluated</em>, and only evaluated on demand.  This aspect of
  Haskell also has benefits for reasoning about programs, but more
  than anything else serves as a barrier to prevent the leakage of
  impure non-functional features into the language: such features
  fundamentally cannot work in conjunction with lazy semantics.

</ul>

<p>Haskell is also <em>strongly-typed</em>, while supporting <em>type
  inference</em> which means that type annotations are rarely necessary.</p>

<p>Those interested in a complete history of Haskell should read
[<a href="bib2.html#haskellhistory">HHPW07</a>].</p>

</section>

<section>
<h2>5.2. High-Level Structure</h2>

<p>At the highest level, GHC can be divided into three distinct chunks:</p>

<ul>

<li>
The compiler itself.  This is essentially a Haskell program
  whose job is to convert Haskell source code into executable machine
  code.
</li>

<li>
The Boot Libraries.  GHC comes with a set of libraries that we
  call the boot libraries, because they constitute the libraries that
  the compiler itself depends on.  Having these libraries in the
  source tree means that GHC can bootstrap itself.  Some of these
  libraries are very tightly coupled to GHC, because they implement
  low-level functionality such as the <code>Int</code> type in terms of
  primitives defined by the compiler and runtime system.  Other
  libraries are more high-level and compiler-independent, such as the
</li>
  <code>Data.Map</code> library.
<li>
The Runtime System (RTS).  This is
  a large library of C code that handles all the tasks associated with
  <em>running</em> the compiled Haskell code, including garbage
  collection, thread scheduling, profiling, exception handling and so
  on.  The RTS is linked into every compiled Haskell program.  The RTS
  represents a significant chunk of the development effort put into
  GHC, and the design decisions made there are responsible for some of
  Haskell's key strengths, such as its efficient support for
  concurrency and parallelism.  We'll describe the RTS in more detail
  in <a href="#s:rts">Section 5.5</a>.
</li>

</ul>

<p>In fact, these three divisions correspond exactly to three
subdirectories of a GHC source tree: <code>compiler</code>,
<code>libraries</code>, and <code>rts</code> respectively.</p>

<p>We won't spend much time here discussing the boot libraries, as they
are largely uninteresting from an architecture standpoint.  All the
key design decisions are embodied in the compiler and runtime system,
so we will devote the rest of this chapter to discussing these two
components.</p>

<section>
<h3>Code Metrics</h3>

<p>The last time we measured the number of lines in GHC was in
1992 ("The Glasgow Haskell compiler: a technical overview",
  JFIT technical conference digest, 1992), so it is interesting to
look at how things have changed since then.  <a href="#f:lines">Figure 5.1</a>
gives a breakdown of the number of lines of code in GHC divided up
into the major components, comparing the current tallies with those
from 1992.</p>

<figure id="f:lines">
  <table class=" table-condensed ">
   <thead>
    <tr><th>Module</th><th>Lines (1992)</th><th>Lines (2011)</th><th>Increase</th></tr>
   </thead>
   <tbody>
    <tr><td colspan="4"><em>Compiler</em></td></tr>
    <tr><td>Main   </td><td align="right">997</td><td align="right">11,150</td><td align="right">11.2</td></tr>
    <tr><td>Parser </td><td align="right">1,055</td><td align="right">4,098</td><td align="right">3.9</td></tr>
    <tr><td>Renamer</td><td align="right">2,828</td><td align="right">4,630</td><td align="right">1.6</td></tr>
    <tr><td>Type checking</td><td align="right">3,352</td><td align="right">24,097</td><td align="right">7.2</td></tr>
    <tr><td>Desugaring</td><td align="right">1,381</td><td align="right">7,091</td><td align="right">5.1</td></tr>
    <tr><td>Core transformations</td><td align="right">1,631</td><td align="right">9,480</td><td align="right">5.8</td></tr>
    <tr><td>STG transformations</td><td align="right">814</td><td align="right">840</td><td align="right">1</td></tr>
    <tr><td>Data-Parallel Haskell</td><td align="right">&mdash;</td><td align="right">3,718</td><td align="right">&mdash;</td></tr>
    <tr><td>Code generation</td><td align="right">2913</td><td align="right">11,003</td><td align="right">3.8</td></tr>
    <tr><td>Native code generation</td><td align="right">&mdash;</td><td align="right">14,138</td><td align="right">&mdash;</td></tr>
    <tr><td>LLVM code generation</td><td align="right">&mdash;</td><td align="right">2,266</td><td align="right">&mdash;</td></tr>
    <tr><td>GHCi</td><td align="right">&mdash;</td><td align="right">7,474</td><td align="right">&mdash;</td></tr>
    <tr><td>Haskell abstract syntax</td><td align="right">2,546</td><td align="right">3,700</td><td align="right">1.5</td></tr>
    <tr><td>Core language</td><td align="right">1,075</td><td align="right">4,798</td><td align="right">4.5</td></tr>
    <tr><td>STG language</td><td align="right">517</td><td align="right">693</td><td align="right">1.3</td></tr>
    <tr><td>C-- (was Abstract C) </td><td align="right">1,416</td><td align="right">7,591</td><td align="right">5.4</td></tr>
    <tr><td>Identifier representations</td><td align="right">1,831</td><td align="right">3,120</td><td align="right">1.7</td></tr>
    <tr><td>Type representations</td><td align="right">1,628</td><td align="right">3,808</td><td align="right">2.3</td></tr>
    <tr><td>Prelude definitions</td><td align="right">3,111</td><td align="right">2,692</td><td align="right">0.9</td></tr>
    <tr><td>Utilities</td><td align="right">1,989</td><td align="right">7,878</td><td align="right">3.96</td></tr>
    <tr><td>Profiling</td><td align="right">191</td><td align="right">367</td><td align="right">1.92</td></tr>
    <tr><td><strong>Compiler Total </strong></td><td align="right"><strong>28,275</strong></td><td align="right"><strong>139,955</strong></td><td align="right"><strong>4.9</strong></td></tr>
    <tr><td colspan="4"><hr/><br/><em>Runtime System</em></td></tr>
    <tr><td>All C and C-- code</td><td align="right">43,865</td><td align="right">48,450</td><td align="right">1.10</td></tr>
   </tbody>
  </table>
  <figcaption>Figure 5.1: Lines of code in GHC, past and present</figcaption>
</figure>

<p>There are some notable aspects of these figures:</p>

<ul>

<li>
Despite nearly 20 years of non-stop development the compiler has
  only increased in size by a factor of 5, from around 28,000 to
  around 140,000 lines of Haskell code.  We obsessively refactor while
  adding new code, keeping the code base as fresh as possible.
</li>

<li>
There are several new components, although these only account
  for about 28,000 new lines.  Much of the new components are
  concerned with code generation: native code generators for various
  processors, and an LLVM code
  generator.  (Formerly the "Low Level Virtual
    Machine", the LLVM project includes a generic code-generator with
    targets for many different processors. For more information see
    <a href="http://llvm.org/">http://llvm.org/</a>, and the chapter on LLVM in Volume 1 of 
    <em>The Architecture of Open Source Applications</em>.) The infrastructure for the interactive interpreter GHCi
  also added over 7,000 lines.
</li>

<li>
The biggest increase in a single component is the type checker,
  where over 20,000 lines were added.  This is unsurprising given that
  much of the recent research using GHC has been into new type system
  extensions (for example GADTs [<a href="bib2.html#gadts">PVWW06</a>] and Type
  Families [<a href="bib2.html#type-families">CKP05</a>]).
</li>

<li>
A lot of code has been added to the <code>Main</code> component; this
  is partly because there was previously a 3,000-line Perl script
  called the "driver" that was rewritten in Haskell and moved into
  GHC proper, and also because support for compiling multiple modules
  was added.
</li>

<li>
The runtime system has barely grown: it is only 10% larger,
  despite having accumulated a lot of new functionality and being
  ported to more platforms.  We rewrote it completely around 1997.
</li>

<li>
GHC has a complex build system, which today comprises about
  6,000 lines of GNU make code.  It is on its fourth complete rewrite,
  the latest being about two years ago, and each successive iteration
  has reduced the amount of code.
</li>

</ul>

</section>

<section>
<h3>The Compiler</h3>

<p>We can divide the compiler into three:</p>

<ul>

<li>
The <em>compilation manager</em>, which is responsible for the
  compilation of multiple Haskell source files.  The job of the
  compilation manager is to figure out in which order to compile the
  different files, and to decide which modules do not need to be
  recompiled because none of their dependencies have changed since the
  last time they were compiled.
</li>

<li>
The <em>Haskell compiler</em> (we abbreviate this as <code>Hsc</code>
  inside GHC), which handles the compilation of a single Haskell
  source file.  As you might imagine, most of the action happens in
  here.  The output of <code>Hsc</code> depends on what backend is selected:
  assembly, LLVM code, or bytecode.
</li>

<li>
The <em>pipeline</em>, which is responsible for composing together
  any necessary external programs with <code>Hsc</code> to compile a Haskell
  source file to object code.  For example, a Haskell source file may
  need preprocessing with the C preprocessor before feeding to
  <code>Hsc</code>, and the output of <code>Hsc</code> is usually an assembly file
  that must be fed into the assembler to create an object file.
</li>

</ul>

<p>The compiler is not simply an executable that performs these
functions; it is itself a <em>library</em> with a large API that can be
used to build other tools that work with Haskell source code, such as
IDEs and analysis tools.</p>

</section>

<section>
<h3>Compiling Haskell Code</h3>

<p>As with most compilers, compiling a Haskell source file proceeds in a
sequence of phases, with the output of each phase becoming the input
of the subsequent phase.  The overall structure of the different
phases is illustrated in <a href="#fig.ghc.pipeline">Figure 5.2</a>.</p>

<figure id="fig.ghc.pipeline">
  <img src="../images/ghc/hscpipe2.png" />
  <figcaption>Figure 5.2: The compiler phases</figcaption>
</figure>

<section>
<h4>Parsing</h4>

<p>We start in the traditional way with parsing, which takes as input a
Haskell source file and produces as output abstract syntax.  In GHC
the abstract syntax datatype <code>HsSyn</code> is parameterised by the
types of the identifiers it contains, so an abstract syntax tree has
type <code>HsSyn t</code> for some type of identifiers <code>t</code>.  This
enables us to add more information to identifiers as the program
passes through the various stages of the compiler, while reusing the
same type of abstract syntax trees.</p>

<p>The output of the parser is an abstract syntax tree in which the
identifiers are simple strings, which we call <code>RdrName</code>.  Hence,
the abstract syntax produced by the parser has type <code>HsSyn RdrName</code>.</p>

<p>GHC uses the tools <code>Alex</code> and <code>Happy</code> to generate its
lexical analysis and parsing code respectively, which are analogous to
the tools <code>lex</code> and <code>yacc</code> for C.</p>

<p>GHC's parser is purely functional.  In fact, the API of the GHC
library provides a pure function called <code>parser</code> that takes a
<code>String</code> (and a few other things) and returns either the parsed
abstract syntax or an error message.</p>

</section>

<section>
<h4>Renaming</h4>

<p>Renaming is the process of resolving all of the identifiers in the
Haskell source code into fully qualified names, at the same time
identifying any out-of-scope identifiers and flagging errors
appropriately.</p>

<p>In Haskell it is possible for a module to re-export an identifier that
it imported from another module.  For example, suppose module <code>A</code>
defines a function called <code>f</code>, and module <code>B</code> imports module
<code>A</code> and re-exports <code>f</code>.  Now, if a module <code>C</code> imports
module <code>B</code>, it can refer to <code>f</code> by the name
<code>B.f</code>&mdash;even though <code>f</code> is originally 
defined in module
<code>A</code>.  This is a useful form of namespace manipulation; it means
that a library can use whatever module structure it likes internally,
but expose a nice clean API via a few interface modules that re-export
identifiers from the internal modules.</p>

<p>The compiler however has to resolve all this, so that it knows what
each name in the source code corresponds to.  We make a clean
distinction between the <em>entities</em>, the "things themselves" (in
our example, <code>A.f</code>), and the names by which the 
entities can be
referred to (e.g., <code>B.f</code>).  At any given point in the source code,
there are a set of entities in scope, and each may be known by one or
more different names.  The job of the renamer is to replace each of
the names in the compiler's internal representation of the code by a
reference to a particular entity.  Sometimes a name can refer to
several different entities; by itself that is not an error, but if the
name is actually used, then the renamer will flag an ambiguity error
and reject the program.</p>

<p>Renaming takes Haskell abstract syntax (<code>HsSyn RdrName</code>) as
input, and also produces abstract syntax as output (<code>HsSyn Name</code>).  
Here a <code>Name</code> is a reference to a particular entity.</p>

<p>Resolving names is the main job of the renamer, but it performs a
plethora of other tasks too: collecting the equations of a function
together and flagging an error if they have differing numbers of
arguments; rearranging infix expressions according to the fixity of
the operators; spotting duplicate declarations; generating warnings
for unused identifiers, and so on.</p>

</section>

<section>
<h4>Type Checking</h4>

<p>Type checking, as one might imagine, is the process of checking that
the Haskell program is type-correct.  If the program passes the type
checker, then it is guaranteed to not crash at runtime. (The
  term "crash" here has a formal definition that includes hard
  crashes like "segmentation fault", but not things like
  pattern-matching failure.  The non-crash guarantee can be subverted
  by using certain unsafe language features, such as the Foreign
  Function Interface.)</p>

<p>The input to the type checker is <code>HsSyn Name</code> (Haskell source
with qualified names), and the output is <code>HsSyn Id</code>.  An
<code>Id</code> is a <code>Name</code> with extra information: notably a
<em>type</em>.  In fact, the Haskell syntax produced by the type checker
is fully decorated with type information: every identifier has its
type attached, and there is enough information to reconstruct the type
of any subexpression (which might be useful for an IDE, for example).</p>

<p>In practice, type checking and renaming may be interleaved, because
the Template Haskell feature generates code at runtime that itself
needs to be renamed and type checked.</p>

</section>

<section>
<h4>Desugaring, and the Core language</h4>

<p>Haskell is a rather large language, containing many different
syntactic forms.  It is intended to be easy for humans to read and
write&mdash;there is a wide range of syntactic constructs which gives the
programmer plenty of flexibility in choosing the most appropriate
construct for the situation at hand.  However, this flexibility means
that there are often several ways to write the same code; for example,
an <code>if</code> expression is identical in meaning to a <code>case</code>
expression with <code>True</code> and <code>False</code> branches, and
list-comprehension notation can be translated into calls to
<code>map</code>, <code>filter</code>, and <code>concat</code>.  In fact, the definition
of the Haskell language defines all these constructs by their
translation into simpler constructs; the constructs that can be
translated away like this are called "syntactic sugar".</p>

<p>It is much simpler for the compiler if all the syntactic sugar is
removed, because the subsequent optimisation passes that need to work
with the Haskell program have a smaller language to deal with.  The
process of desugaring therefore removes all the syntactic sugar,
translating the full Haskell syntax into a much smaller language that
we call <code>Core</code>.  We'll talk about <code>Core</code> in detail
<a href="#s:core">later</a>.</p>

</section>

<section>
<h4>Optimisation</h4>

<p>Now that the program is in <code>Core</code>, the process of optimisation
begins.  One of GHC's great strengths is in optimising away layers of
abstraction, and all of this work happens at the <code>Core</code> level.
<code>Core</code> is a tiny functional language, but it is a tremendously
flexible medium for expressing optimisations, ranging from the very
high-level, such as strictness analysis, to the very low-level, such
as strength reduction.</p>

<p>Each of the optimisation passes takes <code>Core</code> and produces
<code>Core</code>.  The main pass here is called the <em>Simplifier</em>, whose job
it is to perform a large collection of correctness-preserving
transformations, with the goal of producing a more
efficient program.  Some of these transformations are simple and
obvious, such as eliminating dead code or reducing a case expression
when the value being scrutinised is known, and some are more involved,
such as function inlining and applying rewrite rules
(discussed <a href="#s:rules">later</a>).</p>

<p>The simplifier is normally run between the other optimisation passes,
of which there are about six; which passes are actually run and in
which order depends on the optimisation level selected by the user.</p>

</section>

<section>
<h4>Code Generation</h4>

<p>Once the <code>Core</code> program has been optimised, the process of code
generation begins.  After a couple of administrative passes, the code
takes one of two routes: either it is turned into <em>byte code</em> for
execution by the interactive interpreter, or it is passed to the
<em>code generator</em> for eventual translation to machine code.</p>

<p>The code generator first converts the <code>Core</code> into a language called
<code>STG</code>, which is essentially just <code>Core</code> annotated with more
information required by the code generator.  Then, <code>STG</code> is translated
to <code>Cmm</code>, a low-level imperative language with an explicit stack. From
here, the code takes one of three routes:</p>

<ul>

<li>
<strong>Native code generation</strong>: GHC contains simple native code
  generators for a few processor architectures.  This route is fast,
  and generates reasonable code in most cases.
</li>

<li>
<strong>LLVM code generation</strong>: The <code>Cmm</code> is converted to
  LLVM code and passed to the LLVM compiler.  This route can produce
  significantly better code in some cases, although it takes longer
  than the native code generator.
</li>

<li>
<strong>C code generation</strong>: GHC can produce ordinary C code.
  This route produces significantly slower code than the other two
  routes, but can be useful for porting GHC to new platforms.
</li>

</ul>

</section>

</section>

</section>

<section>
<h2>5.3. Key Design Choices</h2>

<p>In this section we focus on a handful of the design choices that have
been particularly effective in GHC.</p>

<section id="s:core">
<h3>The Intermediate Language</h3>

<figure id="fig.ghc.coresyntax">
  <table cellpadding="2">
    <tr><td colspan="3">Expressions</td></tr>
    <tr><td><em>t,e,u</em></td><td>::=</td><td><em>x</em></td><td>Variables</td></tr>
    <tr><td></td><td>|</td><td><em>K</em></td><td>Data constructors</td></tr>
    <tr><td></td><td>|</td><td><em>k</em></td><td>Literals</td></tr>
    <tr><td></td><td>|</td><td>&lambda;<em>&thinsp;x:&sigma;.e</em> | <em>e&thinsp;u</em></td><td>Value abstraction and application</td></tr>
    <tr><td></td><td>|</td><td>&Lambda;<em>&thinsp;a:&eta;.e</em> | <em>e&thinsp;&phi;</em></td><td>Type abstraction and application</td></tr>
    <tr><td></td><td>|</td><td><strong>let</strong> <span style="text-decoration: overline;"><em>x:&tau; = e</em></span> <strong>in</strong> <em>u</em></td>
        <td>Local bindings</td></tr>
    <tr><td></td><td>|</td><td><strong>case</strong> <em>e</em> <strong>of</strong> <span style="text-decoration: overline;"><em>p</em>&rarr;<em>u</em></span></td><td>Case expressions</td></tr>
    <tr><td></td><td>|</td><td>e  &#x25B7;  &gamma;</td><td>Casts</td></tr>
    <tr><td></td><td>|</td><td>&lfloor; &gamma; &rfloor;</td><td>Coercions</td></tr>
    <tr><td><em>p</em></td><td>::=</td><td><em>K</em> <span style="text-decoration: overline;"><em>c:&eta;</em></span> <span style="text-decoration: overline;"><em>x:&tau;</em></span></td>
        <td>Patterns</td></tr>
  </table>
  <figcaption>Figure 5.3: The syntax of <code>Core</code></figcaption>
</figure>

<p>A typical structure for a compiler for a statically-typed language is
this: the program is type checked, and transformed to some
<em>untyped</em> intermediate language, before being optimised.  GHC is
different: it has a <em>statically-typed intermediate language</em>.  As
it turns out, this design choice has had a pervasive effect on the
design and development of GHC.</p>

<p>GHC's intermediate language is called <code>Core</code> (when thinking of the
implementation) or System FC (when thinking about the theory).  Its
syntax is given in <a href="#fig.ghc.coresyntax">Figure 5.3</a>.  The exact details
are not important here; the interested reader can consult
[<a href="bib2.html#system-f">SCPD07</a>] for more details.  For our present purposes,
however, the following points are the key ones:</p>

<ul>

<li>
Haskell is a very large source language.  The data type
  representing its syntax tree has literally hundreds of constructors.

<p>
  In contrast <code>Core</code> is a tiny, principled, lambda calculus.  It has
  extremely few syntactic forms, yet we can translate all of Haskell
  into <code>Core</code>.
</p>
</li>

<li>
Haskell is an <em>implicitly-typed</em> source language.  A
  program may have few or no type annotations; instead it is up to the
  type inference algorithm to figure out the type of every binder and
  sub-expressions.  This type inference algorithm is complex, and
  occasionally somewhat ad hoc, reflecting the design
  compromises that every real programming language embodies.

<p>
  In contrast <code>Core</code> is an <em>explicitly-typed</em> language.  Every
  binder has an explicit type, and terms include explicit type
  abstractions and applications.  <code>Core</code> enjoys a very simple, fast
  type checking algorithm that checks that the program is type
  correct.  The algorithm is entirely straightforward; there are no
  ad hoc compromises.
</p>
</li>

</ul>

<p>All of GHC's analysis and optimisation passes work on <code>Core</code>. This is
great: because <code>Core</code> is such a tiny language an optimisation has
only a few cases to deal with.  Although <code>Core</code> is small, it is
extremely expressive&mdash;System F was, after all, originally developed
as a foundational calculus for typed computation.  When new language
features are added to the source language (and that happens all the
time) the changes are usually restricted to the front end; <code>Core</code>
stays unchanged, and hence so does most of the compiler.</p>

<p>But why is <code>Core</code> typed?  After all, if the type inference engine
accepts the source program, that program is presumably well typed, and
each optimisation pass presumably maintains that type-correctness.
<code>Core</code> may enjoy a fast type checking algorithm, but why would you
ever want to run it?  Moreover, making <code>Core</code> typed carries
significant costs, because every transformation or optimisation pass
must produce a well-typed program, and generating all those type
annotations is often non-trivial.</p>

Nevertheless, it has been a huge win to have an explicitly-typed
intermediate language, for several reasons:

<ul>

<li>
Running the <code>Core</code> type checker (we call it <code>Lint</code>) is a very
  powerful consistency check on the compiler itself.  Imagine that you
  write an "optimisation" that accidentally generates code that
  treats an integer value as a function, and tries to call it.  The
  chances are that the program will segmentation fault, or fail at
  runtime in a bizarre way. Tracing a seg-fault back to the particular
  optimisation pass that broke the program is a long road.

<p>
  Now imagine instead that we run <code>Lint</code> after every optimisation
  pass (and we do, if you use the flag <code>-dcore-lint</code>): it will
  report a precisely located error immediately after the offending
  optimisation.  What a blessing.
</p>

<p>
  Of course, type soundness is not the same as correctness: <code>Lint</code>
  will not signal an error if you "optimise" <code>(x*1)</code> to 1 instead
  of to <em>x</em>.  But if the program passes <code>Lint</code>, it will guarantee to
  run without seg-faults; and moreover in practice we have found that
  it is surprisingly hard to accidentally write optimisations that are
  type-correct but not semantically correct.
</p>
</li>

<li>
The type inference algorithm for Haskell is very large and
    very complex: a glance at <a href="#f:lines">Figure 5.1</a> confirms that the
    type checker is by far the largest single component of GHC.  Large
    and complex means error-prone.  But <code>Lint</code> serves as an 100%
    independent check on the type inference engine; if the type
    inference engine accepts a program that is not, in fact,
    type-correct, <code>Lint</code> will reject it. So <code>Lint</code> serves as a
    powerful auditor of the type inference engine.
</li>

<li>
The existence of <code>Core</code> has also proved to be a tremendous
  sanity check on the <em>design</em> of the source language.  Our users
  constantly suggest new features that they would like in the
  language. Sometimes these features are manifestly "syntactic
  sugar", convenient new syntax for something you can do already. But
  sometimes they are deeper, and it can be hard to tell how
  far-reaching the feature is.

<p>
  <code>Core</code> gives us a precise way to evaluate such features.  If the
  feature can readily be translated into <code>Core</code>, that reassures us
  that nothing fundamentally new is going on: the new feature is
  syntactic-sugar-like. On the other hand, if it would require an
  extension to <code>Core</code>, then we think much, much more carefully.
</p>
</li>

</ul>

<p>In practice <code>Core</code> has been incredibly stable: over a 20-year time
period we have added exactly one new major feature to <code>Core</code> (namely
coercions and their associated casts).  Over the same period, the
source language has evolved enormously.  We attribute this stability
not to our own brilliance, but rather to the fact that <code>Core</code> is
based directly on foundational mathematics: bravo Girard!</p>

</section>

<section>
<h3>Type Checking the Source Language</h3>

<p>One interesting design decision is whether type checking should be
done before or after desugaring.  The trade-offs are these:</p>

<ul>

<li>
Type checking before desugaring means that the type checker must
  deal directly with Haskell's very large syntax, so the type checker
  has many cases to consider.  If we desugared into (an untyped
  variant of) <code>Core</code> first, one might hope that the type checker
  would become much smaller.
</li>

<li>
On the other hand, type checking after desugaring would impose a
  significant new obligation: that desugaring does not affect which
  programs are type-correct.  After all, desugaring implies a
  deliberate loss of information.  It is probably the case that in
  95% of the cases there is no problem, but <em>any</em> problem here
  would force some compromise in the design of <code>Core</code> to preserve
  some extra information.
</li>

<li>
Most seriously of all, type checking a desugared program would
  make it much harder to report errors that relate to the original
  program text, and not to its (sometimes elaborate) desugared
  version.
</li>

</ul>

<p>Most compilers type check after desugaring, but for GHC we made the
opposite choice: we type check the full original Haskell syntax, and
then desugar the result.  It sounds as if adding a new syntactic
construct might be complicated, but (following the French school) we
have structured the type inference engine in a way that makes it
easy. Type inference is split into two parts:</p>

<ol>

<li>
Constraint generation: walk over the source syntax tree,
  generating a collection of type constraints.  This step deals with
  the full syntax of Haskell, but it is very straightforward code, and
  it is easy to add new cases.
</li>

<li>
Constraint solving: solve the gathered constraints.  This is
  where the subtlety of the type inference engine lies, but it is
  independent of the source language syntax, and would be the same for
  a much smaller or much larger language.
</li>

</ol>

<p>On the whole, the type-check-before-desugar design choice has turned
out to be a big win.  Yes, it adds lines of code to the type checker,
but they are <em>simple</em> lines. It avoids giving two conflicting
roles to the same data type, and makes the type inference engine less
complex, and easier to modify. Moreover, GHC's type error messages are
pretty good.</p>

</section>

<section>
<h3>No Symbol Table</h3>

<p>Compilers usually have one or more data structures known as
<em>symbol tables</em>, which are mappings from symbols
(e.g., variables) to some information about the variable, such as its
type, or where in the source code it was defined.</p>

<p>In GHC we use symbol tables quite sparingly; mainly in the renamer and
type checker.  As far as possible, we use an alternative strategy: a
variable is a data structure that <em>contains</em> all the information
about itself.  Indeed, a large amount of information is reachable by
traversing the data structure of a variable: from a variable we can
see its type, which contains type constructors, which contain their
data constructors, which themselves contain types, and so on.  For
example, here are some data types from GHC (heavily abbreviated and
simplified):</p>

<pre>
  data Id      = MkId Name Type
  data Type    = TyConApp TyCon [Type]
               | ....
  data TyCon   = AlgTyCon Name [DataCon]
               | ...
  data DataCon = MkDataCon Name Type ...
</pre>

<p>An <code>Id</code> contains its <code>Type</code>.  A <code>Type</code> might be an
application of a type constructor to some arguments (e.g., <code>Maybe
  Int</code>), in which case it contains the <code>TyCon</code>.  A <code>TyCon</code>
can be an algebraic data type, in which case it includes a list of its
data constructors.  Each <code>DataCon</code> includes its <code>Type</code>,
which of course mentions the <code>TyCon</code>.  And so on.  The whole
structure is highly interconnected.  Indeed it is cyclic; for example,
a <code>TyCon</code> may contain a <code>DataCon</code> which contains a
<code>Type</code>, which contains the very <code>TyCon</code> we started with.</p>

<p>This approach has some advantages and disadvantages:</p>

<ul>

<li>
Many queries that would require a lookup in a symbol table are
  reduced to a simple field access, which is great for efficiency and
  code clarity.
</li>

<li>
There is no need to carry around extra symbol tables, the
  abstract syntax tree already contains all the information.
</li>

<li>
The space overheads are better: all instances of the same
  variable share the same data structure, and there is no space needed
  for the table.
</li>

<li>
The only difficulties arise when we need to <em>change</em> any of
  the information associated with a variable.  This is where a symbol
  table has the advantage: we would just change the entry in the
  symbol table.  In GHC we have to traverse the abstract syntax tree
  and replace all the instances of the old variable with the new one;
  indeed the simplifier does this regularly, as it needs to update
  certain optimisation-related information about each variable.
</li>

</ul>

<p>It is hard to know whether it would be better or worse overall to use
symbol tables, because this aspect of the design is so fundamental
that it is almost impossible to change.  Still, avoiding symbol tables
is a natural choice in the purely functional setting, so it seems
likely that this approach is a good choice for Haskell.</p>

</section>

<section>
<h3>Inter-Module Optimisation</h3>

<p>Functional languages encourage the programmer to write small
definitions.  For example, here is the definition of <code>&amp;&amp;</code> from
the standard library:</p>

<pre>
(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool
True &amp;&amp; True = True
_    &amp;&amp; _    = False
</pre>

<p>If every use of such a function really required a function call,
efficiency would be terrible.  One solution is to make the compiler
treat certain functions specially; another is to use a pre-processor
to replace a "call" with the desired inline code.  All of these
solutions are unsatisfactory in one way or another, especially as
another solution is so obvious: simply inline the function.  To
"inline a function" means to replace the call by a copy of the
function body, suitably instantiating its parameters.</p>

<p>In GHC we have systematically adopted this approach [<a href="bib2.html#inlining">PM02</a>].
Virtually nothing is built into the compiler.  Instead, we define as
much as possible in libraries, and use aggressive inlining to eliminate
the overheads.  This means that <em>programmers can define their own
  libraries that will be inlined and optimised as well as the ones that
  come with GHC</em>.</p>

<p>A consequence is that GHC must be able to do cross-module, and indeed
cross-package, inlining.  The idea is simple:</p>

<ul>

<li>
When compiling a Haskell module <code>Lib.hs</code>, GHC produces
  object code in <code>Lib.o</code> and an "interface file" in
  <code>Lib.hi</code>.  This interface file contains information about all
  the functions that <code>Lib</code> exports, including both their types
  and, for sufficiently small functions, their definitions.
</li>

<li>
When compiling a module <code>Client.hs</code> that imports
  <code>Lib</code>, GHC reads the interface <code>Lib.hi</code>.  So if
  <code>Client</code> calls a function <code>Lib.f</code> defined in <code>Lib</code>,
  GHC can use the information in <code>Lib.hi</code> to inline <code>Lib.f</code>.
</li>

</ul>

<p>By default GHC will expose the definition of a function in the
interface file only if the function is "small" (there are flags to
control this size threshold).  But we also support an INLINE pragma,
to instruct GHC to inline the definition aggressively at call sites,
regardless of size, thus:</p>

<pre>
foo :: Int -&gt; Int 
{-# INLINE foo #-}
foo x = &lt;some big expression&gt;
</pre>

<p>Cross-module inlining is absolutely essential for defining
super-efficient libraries, but it does come with a cost.  If the
author upgrades his library, it is not enough to re-link
<code>Client.o</code> with the new <code>Lib.o</code>,
because <code>Client.o</code>
contains inlined fragments of the old <code>Lib.hs</code>, and they may well
not be compatible with the new one.  Another way to say this is that
the ABI (Application Binary Interface) of <code>Lib.o</code> has changed in
a way that requires recompilation of its clients.</p>

<p>In fact, the only way for compilation to generate code with a fixed,
predictable ABI is to disable cross-module optimisation, and this is
typically too high a price to pay for ABI compatibility.  Users
working with GHC will usually have the source code to their entire
stack available, so recompiling is not normally an issue (and, as we
will describe later, the package system is designed around this mode
of working).  However, there are situations where recompiling is not
practical: distributing bug fixes to libraries in a binary OS
distribution, for example.  In the future we hope it may be possible
to find a compromise solution that allows retaining ABI compatibility
while still allowing some cross-module optimisation to take place.</p>

</section>

</section>

<section>
<h2>5.4. Extensibility</h2>

<p>It is often the case that a project lives or dies according to how
extensible it is.  A monolithic piece of software that is not
extensible has to do everything and do it right, whereas an extensible
piece of software can be a useful base even if it doesn't provide all
the required functionality out of the box.</p>

<p>Open source projects are of course extensible by definition, in that
anyone can take the code and add their own features.  But modifying
the original source code of a project maintained by someone else is
not only a high-overhead approach, it is also not conducive to sharing
your extension with others.  Therefore successful projects tend to
offer forms of extensibility that do not involve modifying the core
code, and GHC is no exception in this respect.</p>

<section id="s:rules">
<h3>User-Defined Rewrite Rules</h3>

<p>The core of GHC is a long sequence of optimisation passes, each of
which performs some semantics-preserving transformation, <code>Core</code>
into <code>Core</code>.  But the author of a library defines functions that
often have some non-trivial, domain-specific transformations of their
own, ones that cannot possibly be predicted by GHC. So GHC allows
library authors to define <em>rewrite rules</em> that are used to
rewrite the program during optimisation
[<a href="bib2.html#playing-by-the-rules">PTH01</a>].  In this way, programmers can,
in effect, extend GHC with domain-specific optimisations.</p>

<p>One example is the <code>foldr/build</code> rule, which is expressed like this:</p>

<pre>
{-# RULES "fold/build"    
    forall k z (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) . 
       foldr k z (build g) = g k z
 #-}
</pre>

<p>The entire rule is a pragma, introduced by <code>{-# RULES</code>.  The rule
  says that whenever GHC sees the expression <code>(foldr k z (build
    g))</code> it should rewrite it to <code>(g k z)</code>.  This transformation
  is semantics-preserving, but it takes a research paper to argue that
  it is [<a href="bib2.html#gill-short-cut">GLP93</a>], so there is no chance of GHC performing
  it automatically.  Together with a handful of other rules, and some
  INLINE pragmas, GHC is able to fuse together list-transforming
  functions.  For example, the two loops in <code>(map f (map g xs))</code>
  are fused into one.</p>

<p>Although rewrite rules are simple and easy to use, they have proved to
be a very powerful extension mechanism.  When we first introduced the
feature into GHC ten years ago we expected it to be an
occasionally useful facility.  But in practice it has turned out to be
useful in very many libraries, whose efficiency often depends
crucially on rewrite rules.  For example, GHC's own <code>base</code>
library contains upward of 100 rules, while the popular <code>vector</code>
library uses several dozen.</p>

</section>

<section>
<h3>Compiler Plugins</h3>

<p>One way in which a compiler can offer extensibility is to allow
programmers to write a pass that is inserted directly into the
compiler's pipeline.  Such passes are often called "plugins".  GHC
supports plugins in the following way:</p>

<ul>

<li>
The programmer writes a <code>Core</code> to <code>Core</code> pass, as an ordinary
  Haskell function in a module <code>P.hs</code>, say, and compiles it to
  object code.
</li>

<li>
When compiling some module, the programmer uses the command-line
  flag <code>-plugin P</code>.  (Alternatively, he can give the flag in a
  pragma at the start of the module.)
</li>

<li>
GHC searches for <code>P.o</code>, dynamically links it into the
  running GHC binary, and calls it at the appropriate point in the
  pipeline.
</li>

</ul>

<p>But what is "the appropriate point in the pipeline"?  GHC does not
know, and so it allows the plugin to make that decision.  As a result
of this and other matters, the API that the plugin must offer is a bit
more complicated than a single <code>Core</code> to <code>Core</code> function&mdash;but not
much.</p>

<p>Plugins sometimes require, or produce, auxiliary plugin-specific data.
For example, a plugin might perform some analysis on the functions in
the module being compiled (<code>M.hs</code>, say), and might want to put
that information in the interface file <code>M.hi</code>, so that the plugin
has access to that information when compiling modules that import
<code>M</code>.  GHC offers an annotation mechanism to support this.</p>

<p>Plugins and annotations are relatively new to GHC.  They have a higher
barrier to entry than rewrite rules, because the plugin is
manipulating GHC's internal data structures, but of course they can do
much more.  It remains to be seen how widely they will be used.</p>

</section>

<section id="s:ghcapi">
<h3>GHC as a Library: The GHC API</h3>

<p>One of GHC's original goals was to be a <em>modular</em> foundation that
others could build on.  We wanted the code of GHC to be as transparent
and well-documented as possible, so that it could be used as the basis
for research projects by others; we imagined that people would want to
make their own modifications to GHC to add new experimental features
or optimisations.  Indeed, there have been some examples of this: for
example, there exists a version of GHC with a Lisp front-end, and a
version of GHC that generates Java code, both developed entirely
separately by individuals with little or no contact with the GHC team.</p>

<p>However, producing modified versions of GHC represents only a small
subset of the ways in which the code of GHC can be re-used.  As the
popularity of the Haskell language has grown, there has been an
increasing need for tools and infrastructure that understand Haskell
source code, and GHC of course contains a lot of the functionality
necessary for building these tools: a Haskell parser, abstract syntax,
type checker and so on.</p>

<p>With this in mind, we made a simple change to GHC: rather than
building GHC as a monolithic program, we build GHC as a
<em>library</em>, that is then linked with a small <em>Main</em> module to
make the GHC executable itself, but also shipped in library form so
that users can call it from their own programs.  At the same time we
built an API to expose GHC's functionality to clients.  The API
provides enough functionality to implement the GHC batch compiler and
the GHCi interactive environment, but it also provides access to
individual passes such as the parser and type checker, and allows the
data structures produced by these passes to be inspected.  This change
has given rise to a wide range of tools built using the GHC API,
including:</p>

<ul>

<li>
A documentation tool,
  <a href="http://www.haskell.org/haddock/">Haddock</a>,
  which reads Haskell source code and produces HTML documentation.
</li>

<li>
New versions of the GHCi front end with additional features;
  e.g., <a href="http://hackage.haskell.org/package/ghci-haskeline">ghci-haskeline</a>
  which was subsequently merged back into GHC.
</li>

<li>
IDEs that offer advanced navigation of Haskell source code;
  e.g., <a href="http://hackage.haskell.org/package/leksah">Leksah</a>.
</li>

<li>
  <a href="http://hackage.haskell.org/package/hint">hint</a>,
  a simpler API for on-the-fly evaluation of Haskell source code.
</li>

</ul>

</section>

<section>
<h3>The Package System</h3>

<p>The package system has been a key factor in the growth in use of the
Haskell language in recent years.  Its main purpose is to enable
Haskell programmers to share code with each other, and as such it is an
important aspect of extensibility: the package system extends the
shared codebase beyond GHC itself.</p>

<p>The package system embodies various pieces of infrastructure that
together make sharing code easy.  With the package system as the
enabler, the community has built a large body of shared code; rather
than relying on libraries from a single source, Haskell programmers
draw on libraries developed by the whole community.  This model has
worked well for other languages; CPAN for Perl, for example, although
Haskell being a predominantly compiled rather than interpreted
language presents a somewhat different set of challenges.</p>

<p>Basically, the package system lets a user manage libraries of Haskell
code written by other people, and use them in their own programs and
libraries.  Installing a Haskell library is as simple as uttering a
single command, for example:</p>

<pre>
$ cabal install zlib
</pre>

<p>downloads the code for the <code>zlib</code> package from
<a href="http://hackage.haskell.org">http://hackage.haskell.org</a>, compiles it using GHC, installs the
compiled code somewhere on your system (e.g., in your home directory
on a Unix system), and registers the installation with GHC.
Furthermore, if <code>zlib</code> depends on any other packages that are not
yet installed, those will also be downloaded, compiled and installed
automatically before <code>zlib</code> itself is compiled.  It is a
tremendously smooth way to work with libraries of Haskell code shared
by others.</p>

<p>The package system is made of four components, only the first of which
is strictly part of the GHC project:</p>

<ul>

<li>
Tools for managing the <em>package database</em>, which is simply
  a repository for information about the packages installed on your
  system.  GHC reads the package database when it starts up, so that
  it knows which packages are available and where to find them.
</li>

<li>
A library called <code>Cabal</code> (Common Architecture for Building
  Applications and Libraries), which implements functionality for
  building, installing and registering individual packages.
</li>

<li>
A website at <a href="http://hackage.haskell.org">http://hackage.haskell.org</a> which hosts
  packages written and uploaded by users.  The website automatically
  builds documentation for the packages which can be browsed online.
  At the time of writing, Hackage is hosting over 3,000 packages
  covering functionality including database libraries, web frameworks,
  GUI toolkits, data structures, and networking.
</li>

<li>
 The <code>cabal</code> tool which ties together the Hackage website
  and the <code>Cabal</code> library: it downloads packages from Hackage,
  resolves dependencies, and builds and installs packages in the right
  order.  New packages can also be uploaded to Hackage using
  <code>cabal</code> from the command line.
</li>

</ul>

<p>These components have been developed over several years by members of
the Haskell community and the GHC team, and together they make a
system that fits perfectly with the open source development model.
There are no barriers to sharing code or using code that others have
shared (provided you respect the relevant licenses, of course).  You
can be using a package that someone else has written literally within
seconds of finding it on Hackage.</p>

<p>Hackage has been so successful that the remaining problems it has are
now those of scale: users find it difficult to choose amongst the four
different database frameworks, for example.  Ongoing developments are
aimed at solving these problems in ways that leverage the community.
For example, allowing users to comment and vote on packages will make
it easier to find the best and most popular packages, and collecting
data on build success or failures from users and reporting the results
will help users avoid packages that are unmaintained or have problems.</p>

</section>

</section>

<section id="s:rts">
<h2>5.5. The Runtime System</h2>

<p>The Runtime System is a library of mostly C code
that is linked into every Haskell program.  It provides the support
infrastructure needed for running the compiled Haskell code, including
the following main components:</p>

<ul>

<li>
Memory management, including a parallel, generational, garbage
  collector;
</li>

<li>
Thread management and scheduling;
</li>

<li>
The primitive operations provided by GHC;
</li>

<li>
A bytecode interpreter and dynamic linker for GHCi.
</li>

</ul>

<p>The rest of this section is divided into two: first we focus on a
couple of the aspects of the design of the RTS that we consider to
have been successful and instrumental in making it work so well, and
secondly we talk about the coding practices and infrastructure we have
built in the RTS for coping with what is a rather hostile programming
environment.</p>

<section>
<h3>Key Design Decisions</h3>

<p>In this section we describe two of the design decisions in the RTS
that we consider to have been particularly successful.</p>

<section>
<h4>The Block Layer</h4>

<p>The garbage collector is built on top of a <em>block layer</em> that
manages memory in units of blocks, where a block is a multiple of 4 KB
in size.  The block layer has a very simple API:</p>

<pre>
typedef struct bdescr_ {
    void *               start;
    struct bdescr_ *     link;
    struct generation_ * gen;   // generation
    // .. various other fields
} bdescr;

bdescr * allocGroup (int n);
void     freeGroup  (bdescr *p);
bdescr * Bdescr     (void *p);  // a macro
</pre>

<p>This is the only API used by the garbage collector for allocating and
deallocating memory.  Blocks of memory are allocated with
<code>allocGroup</code> and freed with <code>freeGroup</code>.  Every block has a
small structure associated with it called a <em>block descriptor</em>
(<code>bdescr</code>).  The operation <code>Bdescr(p)</code> returns the block
descriptor associated with an arbitrary address <code>p</code>; this is
purely an address calculation based on the value of <code>p</code> and
compiles to a handful of arithmetic and bit-manipulation instructions.</p>

<p>Blocks may be linked together into chains using the <code>link</code> field
of the <code>bdescr</code>, and this is the real power of the technique.
The garbage collector needs to manage several distinct areas of memory
such as <em>generations</em>, and each of these areas may need to grow
or shrink over time.  By representing memory areas as linked lists of
blocks, the GC is freed from the difficulties of fitting multiple
resizable memory areas into a flat address space.</p>

<p>The implementation of the block layer uses techniques that are
well-known from C's
<code>malloc()/free()</code> API; it maintains lists of
free blocks of various sizes, and coalesces free areas.  The
operations <code>freeGroup()</code> and <code>allocGroup()</code> are carefully
designed to be <em>O(1)</em>.</p>

<p>One major advantage of this design is that it needs very little
support from the OS, and hence is great for portability.  The block
layer needs to allocate memory in units of 1 MB, aligned to a 1 MB
boundary.  While none of the common OSs provide this functionality
directly, it is implementable without much difficulty in terms of the
facilities they do provide.  The payoff is that GHC has no dependence
on the particular details of the address-space layout used by the OS,
and it coexists peacefully with other users of the address space, such
as shared libraries and operating system threads.</p>

<p>There is a small up-front complexity cost for the block layer, in
terms of managing chains of blocks rather than contiguous memory.
However, we have found that this cost is more than repaid in
flexibility and portability; for example, the block layer enabled a
particularly simple algorithm for parallel GC to be implemented
[<a href="bib2.html#parallel-gc">MHJP08</a>].</p>

</section>

<section>
<h4>Lightweight Threads and Parallelism</h4>

<p>We consider concurrency to be a vitally important programming
abstraction, particularly for building applications like web servers
that need to interact with large numbers of external agents
simultaneously.  If concurrency is an important abstraction, then it
should not be so expensive that programmers are forced to avoid it, or
build elaborate infrastructure to amortise its cost (e.g., thread
pools).  We believe that concurrency should just work, and be cheap
enough that you don't worry about forking threads for small tasks.</p>

<p>All operating systems provide threads that work perfectly well, the
problem is that they are far too expensive.  Typical OSs struggle to
handle thousands of threads, whereas we want to manage threads by the
million.</p>

<p>Green threads, otherwise known as lightweight threads or user-space
threads, are a well-known technique for avoiding the overhead of
operating system threads.  The idea is that threads are managed by the
program itself, or a library (in our case, the RTS), rather than by
the operating system.  Managing threads in user space should be
cheaper, because fewer traps into the operating system are required.</p>

<p>In the GHC RTS we take full advantage of this idea.  A context switch
only occurs when the thread is at a <em>safe point</em>, where very
little additional state needs to be saved.  Because we use accurate
GC, the stack of the thread can be moved and expanded or shrunk on
demand.  Contrast these with OS threads, where every context switch
must save the entire processor state, and where stacks are immovable
so a large chunk of address space has to be reserved up front for each
thread.</p>

<p>Green threads can be vastly more efficient than OS threads, so why
would anyone want to use OS threads?  It comes down to three main
problems:</p>

<ul>

<li>
Blocking and foreign calls.  A thread should be able to make a
  call to an OS API or a foreign library that blocks, without blocking
  all the other threads in the system.
</li>

<li>
Parallelism.  Threads should automatically run in parallel if
  there are multiple processor cores on the system.
</li>

<li>
Some external libraries (notably OpenGL and some GUI libraries)
  have APIs that must be called from the same OS thread each time,
  because they use thread-local state.
</li>

</ul>

<p>It turns out that all of these are difficult to arrange with green
threads.  Nevertheless, we persevered with green threads in GHC and
found solutions to all three:</p>

<ul>

<li>
When a Haskell thread makes a foreign call, another OS thread
  takes over the execution of the remaining Haskell threads
  [<a href="bib2.html#concffi04">MPT04</a>].  A small pool of OS threads are maintained for
  this purpose, and new ones are created on demand.
</li>

<li>
GHC's scheduler multiplexes many lightweight Haskell threads
  onto a few heavyweight OS threads; it implements a transparent M:N
  threading model.  Typically N is chosen to be the same as the number
  of processor cores in the machine, allowing real parallelism to take
  place but without the overhead of having a full OS thread for each
  lightweight Haskell thread.

<p>
  In order to run Haskell code, an OS thread must hold a
  <em>Capability</em>: a data structure that holds the resources required
  to execute Haskell code, such as the nursery (memory where new
  objects are created).  Only one OS thread may hold a given
  Capability at a time.  (We have also called it a "Haskell
    Execution Context", but the code currently uses the Capability
    terminology.)
</p>
</li>

<li>
We provide an API for creating a <em>bound thread</em>: a Haskell
  thread that is tied to one specific OS thread, such that any foreign
  calls made by this Haskell thread are guaranteed to be made by that
  OS thread.
</li>

</ul>

<p>So in the vast majority of cases, Haskell's threads behave exactly
like OS threads: they can make blocking OS calls without affecting
other threads, and they run in parallel on a multicore machine.  But
they are orders of magnitude more efficient, in terms of both time and
space.</p>

<p>Having said that, the implementation does have one problem that users
occasionally run into, especially when running benchmarks.  We
mentioned above that lightweight threads derive some of their
efficiency by only context-switching at "safe points", points in the
code that the compiler designates as safe, where the internal state of
the virtual machine (stack, heap, registers, etc.) is in a tidy state
and garbage collection could take place. In GHC, a safe point is
whenever memory is allocated, which in almost all Haskell programs
happens regularly enough that the program never executes more than a
few tens of instructions without hitting a safe point.  However, it is
possible in highly optimised code to find loops that run for many
iterations without allocating memory. This tends to happen often in
benchmarks (e.g., functions like factorial and Fibonacci).  It occurs
less often in real code, although it does happen.  The lack of safe
points prevents the scheduler from running, which can have detrimental
effects.  It is possible to solve this problem, but not without
impacting the performance of these loops, and often people care about
saving every cycle in their inner loops.  This may just be a
compromise we have to live with.</p>

</section>

</section>

</section>

<section>
<h2>5.6. Developing GHC</h2>

<p>GHC is a single project with a twenty-year life span, and is still in
a ferment of innovation and development.  For the most part our
infrastructure and tooling has been conventional.  For example, we use
a bug tracker (Trac), a wiki (also Trac), and Git for revision
control. (This revision-control mechanism evolved from purely manual,
then CVS, then Darcs, before finally moving to Git in 2010.)  There
are a few points that may be less universal, and we offer them here.</p>

<section>
<h3>Comments and Notes</h3>

<p>One of the most serious difficulties in a large, long-lived project is
keeping technical documentation up to date.  We have no silver bullet,
but we offer one low-tech mechanism that has served us particularly
well: <code>Notes</code>.</p>

<p>When writing code, there is often a moment when a careful programmer
will mentally say something like "This data type has an important
invariant".  She is faced with two choices, both unsatisfactory.  She
can add the invariant as a comment, but that can make the data type
declaration too long, so that it is hard to see what the constructors
are.  Alternatively, she can document the invariant elsewhere, and
risk it going out of date.  Over twenty years, <em>everything</em> goes
out of date!</p>

<p>Thus motivated, we developed the following very simple convention:</p>

<ul>

<li>
Comments of any significant size are not interleaved with code,
  but instead set off by themselves, with a heading in standard form,
  thus:

<pre>
  Note [Equality-constrained types]
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  The type   forall ab. (a ~ [b]) =&gt; blah
  is encoded like this:

     ForAllTy (a:*) $ ForAllTy (b:*) $
     FunTy (TyConApp (~) [a, [b]]) $
     blah
</pre>
</li>

<li>
A the point where the comment is relevant, we add a short
  comment referring to the Note:

<pre>
 data Type
   = FunTy Type Type -- See Note [Equality-constrained types]

   | ...
</pre>

  The comment highlights that something interesting is going on, and
  gives a precise reference to the comment that explains.  It sounds
  trivial, but the precision is vastly better than our previous habit
  of saying "see the comment above", because it often was not clear
  <em>which</em> of the many comments above was intended, and after a
  few years the comment was not even above (it was below, or gone
  altogether).
</li>

</ul>

<p>Not only is it possible to go from the code that refers to the
<code>Note</code> to the <code>Note</code> itself, but the reverse is also
possible, and that is often useful.  Moreover, the same <code>Note</code>
may be referred to from multiple points in the code.</p>

<p>This simple, ASCII-only technique, with no automated support, has
transformed our lives: GHC has around 800 <code>Notes</code>, and the number
grows daily.</p>

</section>

<section>
<h3>How to Keep On Refactoring</h3>

<p>The code of GHC is churning just as quickly as it was ten years ago, 
if not more so.  There is no doubt that the complexity of the
system has increased manyfold over that same time period; we saw
measures of the amount of code in GHC earlier.  Yet, the system
remains manageable.  We attribute this to three main factors:</p>

<ul>

<li>
There's no substitute for good software engineering.  Modularity
  always pays off: making the APIs between components as small as
  possible makes the individual components more flexible because they
  have fewer interdependencies.  For example, GHC's <code>Core{}</code> datatype
  being small reduces the coupling between Core-to-Core passes, to the
  extent that they are almost completely independent and can be run in
  arbitrary order.
</li>

<li>
Developing in a strongly-typed language makes refactoring a
  breeze.  Whenever we need to change a data type, or change the
  number of arguments or type of a function, the compiler immediately
  tells us what other places in the code need to be fixed.  Simply
  having an absolute guarantee that a large class of errors have been
  statically ruled out saves a huge amount of time, especially when
  refactoring.  It is scary to imagine how many hand-written test
  cases we would need to provide the same level of coverage that the
  type system provides.
</li>

<li>
When programming in a purely functional language, it is hard to
  introduce accidental dependencies via state.  If you decide that you
  suddenly need access to a piece of state deep in an algorithm, in an
  imperative language you might be tempted to just make the state
  globally visible rather than explicitly pass it down to the place
  that needs it.  This way eventually leads to a tangle of invisible
  dependencies, and <em>brittle code</em>: code that breaks easily when
  modified.  Pure functional programming forces you to make all the
  dependencies explicit, which exerts some negative pressure on adding
  new dependencies, and fewer dependencies means greater modularity.
  Certainly when it is <em>necessary</em> to add a new dependency then
  purity makes you write more code to express the dependency, but in
  our view it is a worthwhile price to pay for the long-term health of
  the code base.

<p>
  As an added benefit, purely functional code is thread-safe by
  construction and tends to be easier to parallelise.
</p>
</li>

</ul>

</section>

<section>
<h3>Crime Doesn't Pay</h3>

<p>Looking back over the changes we've had to make to GHC as it has
grown, a common lesson emerges: being less than purely functional,
whether for the purposes of efficiency or convenience, tends to have
negative consequences down the road.  We have a couple of great
examples of this:</p>

<ul>

<li>
GHC uses a few data structures that rely on mutation internally.
  One is the <code>FastString</code> type, which uses a single global hash
  table; another is a global <code>NameCache</code> that ensures all
  external names are assigned a unique number.  When we tried to
  parallelise GHC (that is, make GHC compile multiple modules in
  parallel on a multicore processor), these data structures based on
  mutation were the <em>only</em> sticking points.  Had we not resorted
  to mutation in these places, GHC would have been almost trivial to
  parallelise.

<p>
  In fact, although we did build a prototype parallel version of GHC,
  GHC does not currently contain support for parallel compilation, but
  that is largely because we have not yet invested the effort required
  to make these mutable data structures thread-safe.
</p>
</li>

<li>
 GHC's behaviour is governed to a large extent by command-line
  flags.  These command-line flags are by definition constant over a
  given run of GHC, so in early versions of GHC we made the values of
  these flags available as top-level constants. For example, there was
  a top-level value <code>opt_GlasgowExts</code> of type <code>Bool</code>, that
  governed whether certain language extensions should be enabled or
  not.  Top-level constants are highly convenient, because their
  values don't have to be explicitly passed as arguments to all the
  code that needs access to them.

<p>
  Of course these options are not really <em>constants</em>, because
  they change from run to run, and the definition of
  <code>opt_GlasgowExts</code> involves calling <code>unsafePerformIO</code>
  because it hides a side effect.  Nevertheless, this trick is
  normally considered "safe enough" because the value is constant
  within any given run; it doesn't invalidate compiler optimisations,
  for example.
</p>

<p>
  However, GHC was later extended from a single-module compiler to a
  multi-module compiler.  At this point the trick of using top-level
  constants for flags broke, because the flags may have different
  values when compiling different modules.  So we had to refactor
  large amounts of code to pass around the flags explicitly.
</p>

<p>
  Perhaps you might argue that treating the flags as <em>state</em> in
  the first place, as would be natural in an imperative language,
  would have sidestepped the problem.  To some extent this is true,
  although purely functional code has a number of other benefits, not
  least of which is that representing the flags by an immutable data
  structure means that the resulting code is already thread-safe and
  will run in parallel without modification.
</p>
</li>

</ul>

</section>

<section>
<h3>Developing the RTS</h3>

<p>GHC's runtime system presents a stark contrast to the compiler in many
ways.  There is the obvious difference that the runtime system is
written in C rather than Haskell, but there are also considerations
unique to the RTS that give rise to a different design philosophy:</p>

<ol>

<li>
Every Haskell program spends a lot of time executing code in the
  RTS: 20--30% is typical, but characteristics of Haskell programs
  vary a lot and so figures greater or less than this range are also
  common.  Every cycle saved by optimising the RTS is multiplied many
  times over, so it is worth spending a lot of time and effort to save
  those cycles.
</li>

<li>
The runtime system is statically linked into every Haskell
  program (that is, unless dynamic linking is being used), so
  there is an incentive to keep it small.
</li>

<li>
Bugs in the runtime system are often inscrutable to the user
  (e.g., "segmentation fault") and are hard to work around.  For
  example, bugs in the garbage collector tend not to be tied to the
  use of a particular language feature, but arise when some complex
  combination of factors emerges at runtime.  Furthermore, bugs of
  this kind tend to be non-deterministic (only occurring in some
  runs), and highly sensitive (tiny changes to the program make the
  bug disappear).  Bugs in the multithreaded version of the runtime
  system present even greater challenges.  It is therefore worth going
  to extra lengths to prevent these bugs, and also to build
  infrastructure to make identifying them easier.

<p>
  The symptoms of an RTS bug are often indistinguishable from two
  other kinds of failure: hardware failure, which is more common than
  you might think, and misuse of unsafe Haskell features like the FFI
  (Foreign Function Interface).
  The first job in diagnosing a runtime crash is to rule out these two
  other causes.
</p>
</li>

<li>
The RTS is low-level code that runs on several different
  architectures and operating systems, and is regularly ported to new
  ones.  Portability is important.
</li>

</ol>

<p>Every cycle and every byte is important, but correctness is even more
so.  Moreover, the tasks performed by the runtime system are
inherently complex, so correctness is hard to begin with.
Reconciling these has lead us to some interesting defensive
techniques, which we describe in the following sections.</p>

<section id="s:rtsbugs">
<h4>Coping With Complexity</h4>

<p>The RTS is a complex and hostile programming environment.  In contrast
to the compiler, the RTS has almost no type safety.  In fact, it has
even less type safety than most other C programs, because it is
managing data structures whose types live at the Haskell level and not
at the C level.  For example, the RTS has no idea that the object
pointed to by the tail of a cons cell is either <code>[]</code> or another
cons: this information is simply not present at the C level.
Moreover, the process of compiling Haskell code erases types, so even
if we told the RTS that the tail of a cons cell is a list, it would
still have no information about the pointer in the head of the cons
cell.  So the RTS code has to do a lot of casting of C pointer types,
and it gets very little help in terms of type safety from the C
compiler.</p>

<p>So our first weapon in this battle is to <em>avoid putting code in
  the RTS</em>.  Wherever possible, we put the minimum amount of
functionality into the RTS and write the rest in a Haskell library.
This has rarely turned out badly; Haskell code is far more robust and
concise than C, and performance is usually perfectly acceptable.
Deciding where to draw the line is not an exact science, although in
many cases it is reasonably clear.  For example, while it might be
theoretically possible to implement the garbage collector in Haskell,
in practice it is extremely difficult because Haskell does not allow
the programmer precise control of memory allocation, and so dropping
down to C for this kind of low-level task makes practical sense.</p>

<p>There is plenty of functionality that can't be (easily) implemented in
Haskell, and writing code in the RTS is not pleasant.  In the next
section we focus on one aspect of managing complexity and correctness
in the RTS: maintaining invariants.</p>

</section>

</section>

<section>
<h3>Invariants, and Checking Them</h3>

<p>The RTS is full of invariants.  Many of them are trivial and easy to
check: for example, if the pointer to the head of a queue is
<code>NULL</code>, then the pointer to the tail should also be <code>NULL</code>.
The code of the RTS is littered with assertions to check these kinds
of things.  Assertions are our go-to tool for finding bugs before they
manifest; in fact, when a new invariant is added, we often add the
assertion before writing the code that implements the invariant.</p>

<p>Some of the invariants in the runtime are far more difficult to
satisfy, and to check.  One invariant of this kind that pervades more
of the RTS than any other is the following: <em>the heap has no
  dangling pointers</em>.</p>

<p>Dangling pointers are easy to introduce, and there are many places
both in the compiler and the RTS itself that can violate this
invariant.  The code generator could generate code that creates
invalid heap objects; the garbage collector might forget to update the
pointers of some object when it scans the heap.  Tracking down these
kinds of bugs can be extremely time-consuming (it is, however,
  one of the author's favourite activities!), because by the time the
program eventually crashes, execution might have progressed a long way
from where the dangling pointer was originally introduced.  There are
good debugging tools available, but they tend not to be good at
executing the program in reverse. (Recent versions of GDB and
  the Microsoft Visual Studio debugger do have some support for
  reverse execution, however.)</p>

<p>The general principle is: <em>if a program is going to crash, it
  should crash as soon, as noisily, and as often as
  possible.</em> (This quote comes from the GHC coding style
  guidelines, and was originally written by Alastair Reid, who worked
  on an early version of the RTS.)</p>

<p>The problem is, the no-dangling-pointer invariant is not something
that can be checked with a constant-time assertion.  The assertion
that checks it must do a full traversal of the heap!  Clearly we
cannot run this assertion after every heap allocation, or every time
the GC scans an object (indeed, this would not even be enough, as
dangling pointers don't appear until the end of GC, when memory is
freed).</p>

<p>So, the debug RTS has an optional mode that we call <em>sanity
  checking</em>.  Sanity checking enables all kinds of expensive
assertions, and can make the program run many times more slowly.  In
particular, sanity checking runs a full scan of the heap to check for
dangling pointers (amongst other things), before <em>and</em> after
every GC.  The first job when investigating a runtime crash is to run
the program with sanity checking turned on; sometimes this will catch
the invariant violation well before the program actually crashes.</p>

</section>

</section>

<section>
<h2>5.7. Conclusion</h2>

<p>GHC has consumed a significant portion of the authors' lives over the
last 20 years, and we are rather proud of how far it has come.  It is
not the only Haskell implementation, but it is the only one in regular
use by hundreds of thousands of people to get real work done.  We are
constantly surprised when Haskell turns up being used in unusual
places; one recent example is Haskell being used to <a href="http://www.haskell.org/pipermail/haskell-cafe/2010-April/075647.html">control the
systems in a garbage
truck</a>.</p>

<p>For many, Haskell and GHC are synonymous: it was never intended to be
so, and indeed in many ways it is counterproductive to have just one
implementation of a standard, but the fact is that maintaining a good
implementation of a programming language is a lot of work.  We hope
that our efforts in GHC, to support the standard and to clearly delimit
each separate language extension, will make it feasible for more
implementations to emerge and to integrate with the the package system
and other infrastructure.  Competition is good for everyone!</p>

<p>We are deeply indebted to Microsoft in particular for giving us the
opportunity to develop GHC as part of our research and to distribute
it as open source.</p>

</section>


        <!-- Footer
      ================================================== -->
      <footer class="footer">
        <hr>
        <p class="pull-right">This work is made available under
            the <a href="http://creativecommons.org/licenses/by/3.0/legalcode">Creative
            Commons Attribution 3.0 Unported</a> license.  Please see
            the <a href="intro1.html#license">full description of the
            license</a> for details.</a>
            <p><a href="#">Back to top</a><br/>
        <a href="index.html">Back to <em>The Architecture of Open Source Applications</em>.</a></p>
      </footer>

      </div>
    </div>
  </div>

</body>
</html>
