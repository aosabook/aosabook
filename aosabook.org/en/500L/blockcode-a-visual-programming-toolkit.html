<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="provenance" content="$Id: index.html 1472 2012-09-21 22:17:41Z audrey $" />
    <link rel="stylesheet" href="http://aosabook.org/en/500L/theme/css/bootstrap.css" type="text/css" />
    <link rel="stylesheet" href="http://aosabook.org/en/500L/theme/css/bootstrap-responsive.css" type="text/css" />
    <link rel="stylesheet" href="http://aosabook.org/en/500L/theme/css/code.css" type="text/css" />
    <link rel="stylesheet" href="http://aosabook.org/en/500L/theme/css/500L.css" type="text/css" />
    <title>500 Lines or Less | Blockcode: A visual programming toolkit</title>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          },
        });
    </script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>
  <body>
    <div class="container">
      <div class="row">
        <div class="hero-unit">
	  <a class='pull-right' href='/en/index.html'></a>
          <h1>Blockcode: A visual programming toolkit</h1>
          <h2 class="author">Dethe Elza</h2>
          <blockquote class="pull-right">
            </blockquote>

        </div>
      </div>
      <div class="row">
        <div class='span10 offset1' id='content'>
          <p><em><a href="https://twitter.com/dethe">Dethe</a> is a geek dad, aesthetic programmer, mentor, and creator of the <a href="http://waterbearlang.com/">Waterbear</a> visual programming tool. He co-hosts the Vancouver Maker Education Salons and wants to fill the world with robotic origami rabbits.</em></p>

<p>In block-based programming languages, you write programs by dragging and connecting blocks that represent parts of the program. Block-based languages differ from conventional programming languages, in which you type words and symbols.</p>

<p>Learning a programming language can be difficult because they are extremely sensitive to even the slightest of typos. Most programming languages are case-sensitive, have obscure syntax, and will refuse to run if you get so much as a semicolon in the wrong place—or worse, leave one out. Further, most programming languages in use today are based on English and their syntax cannot be localized.</p>

<p>In contrast, a well-done block language can eliminate syntax errors completely. You can still create a program which does the wrong thing, but you cannot create one with the wrong syntax: the blocks just won't fit that way. Block languages are more discoverable: you can see all the constructs and libraries of the language right in the list of blocks. Further, blocks can be localized into any human language without changing the meaning of the programming language.</p>

<div class="center figure">
<a name="figure-1.1"></a><img src="blockcode-images/blockcode_ide.png" alt="Figure 1.1 - The Blockcode IDE in use" title="Figure 1.1 - The Blockcode IDE in use" />
</div>

<p class="center figcaption">
<small>Figure 1.1 - The Blockcode IDE in use</small>
</p>

<p>Block-based languages have a long history, with some of the prominent ones being <a href="http://www.lego.com/en-us/mindstorms/">Lego Mindstorms</a>, <a href="http://www.alice.org/index.php">Alice3D</a>, <a href="http://education.mit.edu/projects/starlogo-tng">StarLogo</a>, and especially <a href="http://scratch.mit.edu/">Scratch</a>. There are several tools for block-based programming on the web as well: <a href="https://developers.google.com/blockly/">Blockly</a>, <a href="http://appinventor.mit.edu/explore/">AppInventor</a>, <a href="http://www.tynker.com/">Tynker</a>, and <a href="http://en.wikipedia.org/wiki/Visual_programming_language">many more</a>.</p>

<p>The code in this chapter is loosely based on the open-source project <a href="http://waterbearlang.com/">Waterbear</a>, which is not a language but a tool for wrapping existing languages with a block-based syntax. Advantages of such a wrapper include the ones noted above: eliminating syntax errors, visual display of available components, ease of localization. Additionally, visual code can sometimes be easier to read and debug, and blocks can be used by pre-typing children. (We could even go further and put icons on the blocks, either in conjunction with the text names or instead of them, to allow pre-literate children to write programs, but we don't go that far in this example.)</p>

<p>The choice of turtle graphics for this language goes back to the Logo language, which was created specifically to teach programming to children. Several of the block-based languages above include turtle graphics, and it is a small enough domain to be able to capture in a tightly constrained project such as this.</p>

<p>If you would like to get a feel for what a block-based-language is like, you can experiment with the program that is built in this chapter from author's <a href="https://dethe.github.io/500lines/blockcode/">GitHub repository</a>.</p>

<h2 id="goals-and-structure">Goals and Structure</h2>

<p>I want to accomplish a couple of things with this code. First and foremost, I want to implement a block language for turtle graphics, with which you can write code to create images through simple dragging-and-dropping of blocks, using as simple a structure of HTML, CSS, and JavaScript as possible. Second, but still important, I want to show how the blocks themselves can serve as a framework for other languages besides our mini turtle language.</p>

<p>To do this, we encapsulate everything that is specific to the turtle language into one file (<code>turtle.js</code>) that we can easily swap with another file. Nothing else should be specific to the turtle language; the rest should just be about handling the blocks (<code>blocks.js</code> and <code>menu.js</code>) or be generally useful web utilities (<code>util.js</code>, <code>drag.js</code>, <code>file.js</code>). That is the goal, although to maintain the small size of the project, some of those utilities are less general-purpose and more specific to their use with the blocks.</p>

<p>One thing that struck me when writing a block language was that the language is its own IDE. You can't just code up blocks in your favourite text editor; the IDE has to be designed and developed in parallel with the block language. This has some pros and cons. On the plus side, everyone will use a consistent environment and there is no room for religious wars about what editor to use. On the downside, it can be a huge distraction from building the block language itself.</p>

<h3 id="the-nature-of-scripts">The Nature of Scripts</h3>

<p>A Blockcode script, like a script in any language (whether block- or text-based), is a sequence of operations to be followed. In the case of Blockcode the script consists of HTML elements which are iterated over, and which are each associated with a particular JavaScript function which will be run when that block's turn comes. Some blocks can contain (and are responsible for running) other blocks, and some blocks can contain numeric arguments which are passed to the functions.</p>

<p>In most (text-based) languages, a script goes through several stages: a lexer converts the text into recognized tokens, a parser organizes the tokens into an abstract syntax tree, then depending on the language the program may be compiled into machine code or fed into an interpreter. That's a simplification; there can be more steps. For Blockcode, the layout of the blocks in the script area already represents our abstract syntax tree, so we don't have to go through the lexing and parsing stages. We use the Visitor pattern to iterate over those blocks and call predefined JavaScript functions associated with each block to run the program.</p>

<p>There is nothing stopping us from adding additional stages to be more like a traditional language. Instead of simply calling associated JavaScript functions, we could replace <code>turtle.js</code> with a block language that emits byte codes for a different virtual machine, or even C++ code for a compiler. Block languages exist (as part of the Waterbear project) for generating Java robotics code, for programming Arduino, and for scripting Minecraft running on Raspberry Pi.</p>

<h3 id="web-applications">Web Applications</h3>

<p>In order to make the tool available to the widest possible audience, it is web-native. It's written in HTML, CSS, and JavaScript, so it should work in most browsers and platforms.</p>

<p>Modern web browsers are powerful platforms, with a rich set of tools for building great apps. If something about the implementation became too complex, I took that as a sign that I wasn't doing it &quot;the web way&quot; and, where possible, tried to re-think how to better use the browser tools.</p>

<p>An important difference between web applications and traditional desktop or server applications is the lack of a <code>main()</code> or other entry point. There is no explicit run loop because that is already built into the browser and implicit on every web page. All our code will be parsed and executed on load, at which point we can register for events we are interested in for interacting with the user. After the first run, all further interaction with our code will be through callbacks we set up and register, whether we register those for events (like mouse movement), timeouts (fired with the periodicity we specify), or frame handlers (called for each screen redraw, generally 60 frames per second). The browser does not expose full-featured threads either (only shared-nothing web workers).</p>

<h2 id="stepping-through-the-code">Stepping Through the Code</h2>

<p>I've tried to follow some conventions and best practices throughout this project. Each JavaScript file is wrapped in a function to avoid leaking variables into the global environment. If it needs to expose variables to other files it will define a single global per file, based on the filename, with the exposed functions in it. This will be near the end of the file, followed by any event handlers set by that file, so you can always glance at the end of a file to see what events it handles and what functions it exposes.</p>

<p>The code style is procedural, not object-oriented or functional. We could do the same things in any of these paradigms, but that would require more setup code and wrappers to impose on what exists already for the DOM. Recent work on <a href="http://webcomponents.org/">Custom Elements</a> make it easier to work with the DOM in an OO way, and there has been a lot of great writing on <a href="https://leanpub.com/javascript-allonge/read">Functional JavaScript</a>, but either would require a bit of shoe-horning, so it felt simpler to keep it procedural.</p>

<p>There are eight source files in this project, but <code>index.html</code> and <code>blocks.css</code> are basic structure and style for the app and won't be discussed. Two of the JavaScript files won't be discussed in any detail either: <code>util.js</code> contains some helpers and serves as a bridge between different browser implementations—similar to a library like jQuery but in less than 50 lines of code. <code>file.js</code> is a similar utility used for loading and saving files and serializing scripts.</p>

<p>These are the remaining files:</p>

<ul>
<li><code>block.js</code> is the abstract representation of a block-based language.</li>
<li><code>drag.js</code> implements the key interaction of the language: allowing the user to drag blocks from a list of available blocks (the &quot;menu&quot;) to assemble them into a program (the &quot;script&quot;).</li>
<li><code>menu.js</code> has some helper code and is also responsible for actually running the user's program.</li>
<li><code>turtle.js</code> defines the specifics of our block language (turtle graphics) and initializes its specific blocks. This is the file that would be replaced in order to create a different block language.</li>
</ul>

<h3 id="blocks.js"><code>blocks.js</code></h3>

<p>Each block consists of a few HTML elements, styled with CSS, with some JavaScript event handlers for dragging-and-dropping and modifying the input argument. The <code>blocks.js</code> file helps to create and manage these groupings of elements as single objects. When a type of block is added to the block menu, it is associated with a JavaScript function to implement the language, so each block in the script has to be able to find its associated function and call it when the script runs.</p>

<div class="center figure">
<a name="figure-1.2"></a><img src="blockcode-images/block.png" alt="Figure 1.2 - An example block" title="Figure 1.2 - An example block" />
</div>

<p class="center figcaption">
<small>Figure 1.2 - An example block</small>
</p>

<p>Blocks have two optional bits of structure. They can have a single numeric parameter (with a default value), and they can be a container for other blocks. These are hard limits to work with, but would be relaxed in a larger system. In Waterbear there are also expression blocks which can be passed in as parameters; multiple parameters of a variety of types are supported. Here in the land of tight constraints we'll see what we can do with just one type of parameter.</p>

<pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- The HTML structure of a block --&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;block&quot;</span><span class="ot"> draggable=</span><span class="st">&quot;true&quot;</span><span class="ot"> data-name=</span><span class="st">&quot;Right&quot;</span><span class="kw">&gt;</span>
    Right
    <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;number&quot;</span><span class="ot"> value=</span><span class="st">&quot;5&quot;</span><span class="kw">&gt;</span>
    degrees
<span class="kw">&lt;/div&gt;</span></code></pre>

<p>It's important to note that there is no real distinction between blocks in the menu and blocks in the script. Dragging treats them slightly differently based on where they are being dragged from, and when we run a script it only looks at the blocks in the script area, but they are fundamentally the same structures, which means we can clone the blocks when dragging from the menu into the script.</p>

<p>The <code>createBlock(name, value, contents)</code> function returns a block as a DOM element populated with all internal elements, ready to insert into the document. This can be used to create blocks for the menu, or for restoring script blocks saved in files or <code>localStorage</code>. While it is flexible this way, it is built specifically for the Blockcode &quot;language&quot; and makes assumptions about it, so if there is a value it assumes the value represents a numeric argument and creates an input of type &quot;number&quot;. Since this is a limitation of the Blockcode, this is fine, but if we were to extend the blocks to support other types of arguments, or more than one argument, the code would have to change.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">createBlock</span>(name, value, contents){
        <span class="kw">var</span> item = <span class="fu">elem</span>(<span class="st">&#39;div&#39;</span>,
            {<span class="st">&#39;class&#39;</span>: <span class="st">&#39;block&#39;</span>, <span class="dt">draggable</span>: <span class="kw">true</span>, <span class="st">&#39;data-name&#39;</span>: name},
            [name]
        );
        <span class="kw">if</span> (value !== <span class="kw">undefined</span> &amp;&amp; value !== <span class="kw">null</span>){
            <span class="ot">item</span>.<span class="fu">appendChild</span>(<span class="fu">elem</span>(<span class="st">&#39;input&#39;</span>, {<span class="dt">type</span>: <span class="st">&#39;number&#39;</span>, <span class="dt">value</span>: value}));
        }
        <span class="kw">if</span> (<span class="ot">Array</span>.<span class="fu">isArray</span>(contents)){
            <span class="ot">item</span>.<span class="fu">appendChild</span>(
                <span class="fu">elem</span>(<span class="st">&#39;div&#39;</span>, {<span class="st">&#39;class&#39;</span>: <span class="st">&#39;container&#39;</span>}, <span class="ot">contents</span>.<span class="fu">map</span>(<span class="kw">function</span>(block){
                <span class="kw">return</span> <span class="ot">createBlock</span>.<span class="fu">apply</span>(<span class="kw">null</span>, block);
            })));
        }<span class="kw">else</span> <span class="kw">if</span> (<span class="kw">typeof</span> contents === <span class="st">&#39;string&#39;</span>){
            <span class="co">// Add units (degrees, etc.) specifier</span>
            <span class="ot">item</span>.<span class="fu">appendChild</span>(<span class="ot">document</span>.<span class="fu">createTextNode</span>(<span class="st">&#39; &#39;</span> + contents));
        }
        <span class="kw">return</span> item;
    }</code></pre>

<p>We have some utilities for handling blocks as DOM elements:</p>

<ul>
<li><code>blockContents(block)</code> retrieves the child blocks of a container block. It always returns a list if called on a container block, and always returns null on a simple block</li>
<li><code>blockValue(block)</code> returns the numerical value of the input on a block if the block has an input field of type number, or null if there is no input element for the block</li>
<li><code>blockScript(block)</code> will return a structure suitable for serializing with JSON, to save blocks in a form they can easily be restored from</li>
<li><code>runBlocks(blocks)</code> is a handler that runs each block in an array of blocks</li>
</ul>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">blockContents</span>(block){
        <span class="kw">var</span> container = <span class="ot">block</span>.<span class="fu">querySelector</span>(<span class="st">&#39;.container&#39;</span>);
        <span class="kw">return</span> container ? [].<span class="ot">slice</span>.<span class="fu">call</span>(<span class="ot">container</span>.<span class="fu">children</span>) : <span class="kw">null</span>;
    }

    <span class="kw">function</span> <span class="fu">blockValue</span>(block){
        <span class="kw">var</span> input = <span class="ot">block</span>.<span class="fu">querySelector</span>(<span class="st">&#39;input&#39;</span>);
        <span class="kw">return</span> input ? <span class="fu">Number</span>(<span class="ot">input</span>.<span class="fu">value</span>) : <span class="kw">null</span>;
    }

    <span class="kw">function</span> <span class="fu">blockUnits</span>(block){
        <span class="kw">if</span> (<span class="ot">block</span>.<span class="ot">children</span>.<span class="fu">length</span> &gt; <span class="dv">1</span> &amp;&amp;
            <span class="ot">block</span>.<span class="ot">lastChild</span>.<span class="fu">nodeType</span> === <span class="ot">Node</span>.<span class="fu">TEXT_NODE</span> &amp;&amp;
            <span class="ot">block</span>.<span class="ot">lastChild</span>.<span class="fu">textContent</span>){
            <span class="kw">return</span> <span class="ot">block</span>.<span class="ot">lastChild</span>.<span class="ot">textContent</span>.<span class="fu">slice</span>(<span class="dv">1</span>);
        }
    }

    <span class="kw">function</span> <span class="fu">blockScript</span>(block){
        <span class="kw">var</span> script = [<span class="ot">block</span>.<span class="ot">dataset</span>.<span class="fu">name</span>];
        <span class="kw">var</span> value = <span class="fu">blockValue</span>(block);
        <span class="kw">if</span> (value !== <span class="kw">null</span>){
            <span class="ot">script</span>.<span class="fu">push</span>(<span class="fu">blockValue</span>(block));
        }
        <span class="kw">var</span> contents = <span class="fu">blockContents</span>(block);
        <span class="kw">var</span> units = <span class="fu">blockUnits</span>(block);
        <span class="kw">if</span> (contents){<span class="ot">script</span>.<span class="fu">push</span>(<span class="ot">contents</span>.<span class="fu">map</span>(blockScript));}
        <span class="kw">if</span> (units){<span class="ot">script</span>.<span class="fu">push</span>(units);}
        <span class="kw">return</span> <span class="ot">script</span>.<span class="fu">filter</span>(<span class="kw">function</span>(notNull){ <span class="kw">return</span> notNull !== <span class="kw">null</span>; });
    }

    <span class="kw">function</span> <span class="fu">runBlocks</span>(blocks){
        <span class="ot">blocks</span>.<span class="fu">forEach</span>(<span class="kw">function</span>(block){ <span class="fu">trigger</span>(<span class="st">&#39;run&#39;</span>, block); });
    }</code></pre>

<h3 id="drag.js"><code>drag.js</code></h3>

<p>The purpose of <code>drag.js</code> is to turn static blocks of HTML into a dynamic programming language by implementing interactions between the menu section of the view and the script section. The user builds their program by dragging blocks from the menu into the script, and the system runs the blocks in the script area.</p>

<p>We're using HTML5 drag-and-drop; the specific JavaScript event handlers it requires are defined here. (For more information on using HTML5 drag-and-drop, see <a href="http://www.html5rocks.com/en/tutorials/dnd/basics/">Eric Bidleman's article</a>.) While it is nice to have built-in support for drag-and-drop, it does have some oddities and some pretty major limitations, like not being implemented in any mobile browser at the time of this writing.</p>

<p>We define some variables at the top of the file. When we're dragging, we'll need to reference these from different stages of the dragging callback dance.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">var</span> dragTarget = <span class="kw">null</span>; <span class="co">// Block we&#39;re dragging</span>
    <span class="kw">var</span> dragType = <span class="kw">null</span>; <span class="co">// Are we dragging from the menu or from the script?</span>
    <span class="kw">var</span> scriptBlocks = []; <span class="co">// Blocks in the script, sorted by position</span></code></pre>

<p>Depending on where the drag starts and ends, <code>drop</code> will have different effects:</p>

<ul>
<li>If dragging from script to menu, delete <code>dragTarget</code> (remove block from script).</li>
<li>If dragging from script to script, move <code>dragTarget</code> (move an existing script block).</li>
<li>If dragging from menu to script, copy <code>dragTarget</code> (insert new block in script).</li>
<li>If dragging from menu to menu, do nothing.</li>
</ul>

<p>During the <code>dragStart(evt)</code> handler we start tracking whether the block is being copied from the menu or moved from (or within) the script. We also grab a list of all the blocks in the script which are not being dragged, to use later. The <code>evt.dataTransfer.setData</code> call is used for dragging between the browser and other applications (or the desktop), which we're not using, but have to call anyway to work around a bug.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">dragStart</span>(evt){
        <span class="kw">if</span> (!<span class="fu">matches</span>(<span class="ot">evt</span>.<span class="fu">target</span>, <span class="st">&#39;.block&#39;</span>)) <span class="kw">return</span>;
        <span class="kw">if</span> (<span class="fu">matches</span>(<span class="ot">evt</span>.<span class="fu">target</span>, <span class="st">&#39;.menu .block&#39;</span>)){
            dragType = <span class="st">&#39;menu&#39;</span>;
        }<span class="kw">else</span>{
            dragType = <span class="st">&#39;script&#39;</span>;
        }
        <span class="ot">evt</span>.<span class="ot">target</span>.<span class="ot">classList</span>.<span class="fu">add</span>(<span class="st">&#39;dragging&#39;</span>);
        dragTarget = <span class="ot">evt</span>.<span class="fu">target</span>;
        scriptBlocks = [].<span class="ot">slice</span>.<span class="fu">call</span>(
            <span class="ot">document</span>.<span class="fu">querySelectorAll</span>(<span class="st">&#39;.script .block:not(.dragging)&#39;</span>));
        <span class="co">// For dragging to take place in Firefox, we have to set this, even if</span>
        <span class="co">// we don&#39;t use it</span>
        <span class="ot">evt</span>.<span class="ot">dataTransfer</span>.<span class="fu">setData</span>(<span class="st">&#39;text/html&#39;</span>, <span class="ot">evt</span>.<span class="ot">target</span>.<span class="fu">outerHTML</span>);
        <span class="kw">if</span> (<span class="fu">matches</span>(<span class="ot">evt</span>.<span class="fu">target</span>, <span class="st">&#39;.menu .block&#39;</span>)){
            <span class="ot">evt</span>.<span class="ot">dataTransfer</span>.<span class="fu">effectAllowed</span> = <span class="st">&#39;copy&#39;</span>;
        }<span class="kw">else</span>{
            <span class="ot">evt</span>.<span class="ot">dataTransfer</span>.<span class="fu">effectAllowed</span> = <span class="st">&#39;move&#39;</span>;
        }
    }</code></pre>

<p>While we are dragging, the <code>dragenter</code>, <code>dragover</code>, and <code>dragout</code> events give us opportunities to add visual cues by highlighting valid drop targets, etc. Of these, we only make use of <code>dragover</code>.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">dragOver</span>(evt){
        <span class="kw">if</span> (!<span class="fu">matches</span>(<span class="ot">evt</span>.<span class="fu">target</span>, <span class="st">&#39;.menu, .menu *, .script, .script *, .content&#39;</span>)) {
            <span class="kw">return</span>;
        }
        <span class="co">// Necessary. Allows us to drop.</span>
        <span class="kw">if</span> (<span class="ot">evt</span>.<span class="fu">preventDefault</span>) { <span class="ot">evt</span>.<span class="fu">preventDefault</span>(); }
        <span class="kw">if</span> (dragType === <span class="st">&#39;menu&#39;</span>){
            <span class="co">// See the section on the DataTransfer object.</span>
            <span class="ot">evt</span>.<span class="ot">dataTransfer</span>.<span class="fu">dropEffect</span> = <span class="st">&#39;copy&#39;</span>;  
        }<span class="kw">else</span>{
            <span class="ot">evt</span>.<span class="ot">dataTransfer</span>.<span class="fu">dropEffect</span> = <span class="st">&#39;move&#39;</span>;
        }
        <span class="kw">return</span> <span class="kw">false</span>;
    }</code></pre>

<p>When we release the mouse, we get a <code>drop</code> event. This is where the magic happens. We have to check where we dragged from (set back in <code>dragStart</code>) and where we have dragged to. Then we either copy the block, move the block, or delete the block as needed. We fire off some custom events using <code>trigger()</code> (defined in <code>util.js</code>) for our own use in the block logic, so we can refresh the script when it changes.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">drop</span>(evt){
        <span class="kw">if</span> (!<span class="fu">matches</span>(<span class="ot">evt</span>.<span class="fu">target</span>, <span class="st">&#39;.menu, .menu *, .script, .script *&#39;</span>)) <span class="kw">return</span>;
        <span class="kw">var</span> dropTarget = <span class="fu">closest</span>(
            <span class="ot">evt</span>.<span class="fu">target</span>, <span class="st">&#39;.script .container, .script .block, .menu, .script&#39;</span>);
        <span class="kw">var</span> dropType = <span class="st">&#39;script&#39;</span>;
        <span class="kw">if</span> (<span class="fu">matches</span>(dropTarget, <span class="st">&#39;.menu&#39;</span>)){ dropType = <span class="st">&#39;menu&#39;</span>; }
        <span class="co">// stops the browser from redirecting.</span>
        <span class="kw">if</span> (<span class="ot">evt</span>.<span class="fu">stopPropagation</span>) { <span class="ot">evt</span>.<span class="fu">stopPropagation</span>(); }
        <span class="kw">if</span> (dragType === <span class="st">&#39;script&#39;</span> &amp;&amp; dropType === <span class="st">&#39;menu&#39;</span>){
            <span class="fu">trigger</span>(<span class="st">&#39;blockRemoved&#39;</span>, <span class="ot">dragTarget</span>.<span class="fu">parentElement</span>, dragTarget);
            <span class="ot">dragTarget</span>.<span class="ot">parentElement</span>.<span class="fu">removeChild</span>(dragTarget);
        }<span class="kw">else</span> <span class="kw">if</span> (dragType ===<span class="st">&#39;script&#39;</span> &amp;&amp; dropType === <span class="st">&#39;script&#39;</span>){
            <span class="kw">if</span> (<span class="fu">matches</span>(dropTarget, <span class="st">&#39;.block&#39;</span>)){
                <span class="ot">dropTarget</span>.<span class="ot">parentElement</span>.<span class="fu">insertBefore</span>(
                    dragTarget, <span class="ot">dropTarget</span>.<span class="fu">nextSibling</span>);
            }<span class="kw">else</span>{
                <span class="ot">dropTarget</span>.<span class="fu">insertBefore</span>(dragTarget, <span class="ot">dropTarget</span>.<span class="fu">firstChildElement</span>);
            }
            <span class="fu">trigger</span>(<span class="st">&#39;blockMoved&#39;</span>, dropTarget, dragTarget);
        }<span class="kw">else</span> <span class="kw">if</span> (dragType === <span class="st">&#39;menu&#39;</span> &amp;&amp; dropType === <span class="st">&#39;script&#39;</span>){
            <span class="kw">var</span> newNode = <span class="ot">dragTarget</span>.<span class="fu">cloneNode</span>(<span class="kw">true</span>);
            <span class="ot">newNode</span>.<span class="ot">classList</span>.<span class="fu">remove</span>(<span class="st">&#39;dragging&#39;</span>);
            <span class="kw">if</span> (<span class="fu">matches</span>(dropTarget, <span class="st">&#39;.block&#39;</span>)){
                <span class="ot">dropTarget</span>.<span class="ot">parentElement</span>.<span class="fu">insertBefore</span>(
                    newNode, <span class="ot">dropTarget</span>.<span class="fu">nextSibling</span>);
            }<span class="kw">else</span>{
                <span class="ot">dropTarget</span>.<span class="fu">insertBefore</span>(newNode, <span class="ot">dropTarget</span>.<span class="fu">firstChildElement</span>);
            }
            <span class="fu">trigger</span>(<span class="st">&#39;blockAdded&#39;</span>, dropTarget, newNode);
        }
    }</code></pre>

<p>The <code>dragEnd(evt)</code> is called when we mouse up, but after we handle the <code>drop</code> event. This is where we can clean up, remove classes from elements, and reset things for the next drag.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">_findAndRemoveClass</span>(klass){
        <span class="kw">var</span> elem = <span class="ot">document</span>.<span class="fu">querySelector</span>(<span class="st">&#39;.&#39;</span> + klass);
        <span class="kw">if</span> (elem){ <span class="ot">elem</span>.<span class="ot">classList</span>.<span class="fu">remove</span>(klass); }
    }

    <span class="kw">function</span> <span class="fu">dragEnd</span>(evt){
        <span class="fu">_findAndRemoveClass</span>(<span class="st">&#39;dragging&#39;</span>);
        <span class="fu">_findAndRemoveClass</span>(<span class="st">&#39;over&#39;</span>);
        <span class="fu">_findAndRemoveClass</span>(<span class="st">&#39;next&#39;</span>);
    }</code></pre>

<h3 id="menu.js"><code>menu.js</code></h3>

<p>The file <code>menu.js</code> is where blocks are associated with the functions that are called when they run, and contains the code for actually running the script as the user builds it up. Every time the script is modified, it is re-run automatically.</p>

<p>&quot;Menu&quot; in this context is not a drop-down (or pop-up) menu, like in most applications, but is the list of blocks you can choose for your script. This file sets that up, and starts the menu off with a looping block that is generally useful (and thus not part of the turtle language itself). This is kind of an odds-and-ends file, for things that may not fit anywhere else.</p>

<p>Having a single file to gather random functions in is useful, especially when an architecture is under development. My theory of keeping a clean house is to have designated places for clutter, and that applies to building a program architecture too. One file or module becomes the catch-all for things that don't have a clear place to fit in yet. As this file grows it is important to watch for emerging patterns: several related functions can be spun off into a separate module (or joined together into a more general function). You don't want the catch-all to grow indefinitely, but only to be a temporary holding place until you figure out the right way to organize the code.</p>

<p>We keep around references to <code>menu</code> and <code>script</code> because we use them a lot; no point hunting through the DOM for them over and over. We'll also use <code>scriptRegistry</code>, where we store the scripts of blocks in the menu. We use a very simple name-to-script mapping which does not support either multiple menu blocks with the same name or renaming blocks. A more complex scripting environment would need something more robust.</p>

<p>We use <code>scriptDirty</code> to keep track of whether the script has been modified since the last time it was run, so we don't keep trying to run it constantly.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">var</span> menu = <span class="ot">document</span>.<span class="fu">querySelector</span>(<span class="st">&#39;.menu&#39;</span>);
    <span class="kw">var</span> script = <span class="ot">document</span>.<span class="fu">querySelector</span>(<span class="st">&#39;.script&#39;</span>);
    <span class="kw">var</span> scriptRegistry = {};
    <span class="kw">var</span> scriptDirty = <span class="kw">false</span>;</code></pre>

<p>When we want to notify the system to run the script during the next frame handler, we call <code>runSoon()</code> which sets the <code>scriptDirty</code> flag to <code>true</code>. The system calls <code>run()</code> on every frame, but returns immediately unless <code>scriptDirty</code> is set. When <code>scriptDirty</code> is set, it runs all the script blocks, and also triggers events to let the specific language handle any tasks it needs before and after the script is run. This decouples the blocks-as-toolkit from the turtle language to make the blocks re-usable (or the language pluggable, depending how you look at it).</p>

<p>As part of running the script, we iterate over each block, calling <code>runEach(evt)</code> on it, which sets a class on the block, then finds and executes its associated function. If we slow things down, you should be able to watch the code execute as each block highlights to show when it is running.</p>

<p>The <code>requestAnimationFrame</code> method below is provided by the browser for animation. It takes a function which will be called for the next frame to be rendered by the browser (at 60 frames per second) after the call is made. How many frames we actually get depends on how fast we can get work done in that call.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">runSoon</span>(){ scriptDirty = <span class="kw">true</span>; }

    <span class="kw">function</span> <span class="fu">run</span>(){
        <span class="kw">if</span> (scriptDirty){
            scriptDirty = <span class="kw">false</span>;
            <span class="ot">Block</span>.<span class="fu">trigger</span>(<span class="st">&#39;beforeRun&#39;</span>, script);
            <span class="kw">var</span> blocks = [].<span class="ot">slice</span>.<span class="fu">call</span>(
                <span class="ot">document</span>.<span class="fu">querySelectorAll</span>(<span class="st">&#39;.script &gt; .block&#39;</span>));
            <span class="ot">Block</span>.<span class="fu">run</span>(blocks);
            <span class="ot">Block</span>.<span class="fu">trigger</span>(<span class="st">&#39;afterRun&#39;</span>, script);
        }<span class="kw">else</span>{
            <span class="ot">Block</span>.<span class="fu">trigger</span>(<span class="st">&#39;everyFrame&#39;</span>, script);
        }
        <span class="fu">requestAnimationFrame</span>(run);
    }
    <span class="fu">requestAnimationFrame</span>(run);

    <span class="kw">function</span> <span class="fu">runEach</span>(evt){
        <span class="kw">var</span> elem = <span class="ot">evt</span>.<span class="fu">target</span>;
        <span class="kw">if</span> (!<span class="fu">matches</span>(elem, <span class="st">&#39;.script .block&#39;</span>)) <span class="kw">return</span>;
        <span class="kw">if</span> (<span class="ot">elem</span>.<span class="ot">dataset</span>.<span class="fu">name</span> === <span class="st">&#39;Define block&#39;</span>) <span class="kw">return</span>;
        <span class="ot">elem</span>.<span class="ot">classList</span>.<span class="fu">add</span>(<span class="st">&#39;running&#39;</span>);
        scriptRegistry[<span class="ot">elem</span>.<span class="ot">dataset</span>.<span class="fu">name</span>](elem);
        <span class="ot">elem</span>.<span class="ot">classList</span>.<span class="fu">remove</span>(<span class="st">&#39;running&#39;</span>);
    }</code></pre>

<p>We add blocks to the menu using <code>menuItem(name, fn, value, contents)</code> which takes a normal block, associates it with a function, and puts in the menu column.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">menuItem</span>(name, fn, value, units){
        <span class="kw">var</span> item = <span class="ot">Block</span>.<span class="fu">create</span>(name, value, units);
        scriptRegistry[name] = fn;
        <span class="ot">menu</span>.<span class="fu">appendChild</span>(item);
        <span class="kw">return</span> item;
    }</code></pre>

<p>We define <code>repeat(block)</code> here, outside of the turtle language, because it is generally useful in different languages. If we had blocks for conditionals and reading and writing variables they could also go here, or into a separate trans-language module, but right now we only have one of these general-purpose blocks defined.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">repeat</span>(block){
        <span class="kw">var</span> count = <span class="ot">Block</span>.<span class="fu">value</span>(block);
        <span class="kw">var</span> children = <span class="ot">Block</span>.<span class="fu">contents</span>(block);
        <span class="kw">for</span> (<span class="kw">var</span> i = <span class="dv">0</span>; i &lt; count; i++){
            <span class="ot">Block</span>.<span class="fu">run</span>(children);
        }
    }
    <span class="fu">menuItem</span>(<span class="st">&#39;Repeat&#39;</span>, repeat, <span class="dv">10</span>, []);</code></pre>

<h3 id="turtle.js"><code>turtle.js</code></h3>

<p><code>turtle.js</code> is the implementation of the turtle block language. It exposes no functions to the rest of the code, so nothing else can depend on it. This way we can swap out the one file to create a new block language and know nothing in the core will break.</p>

<div class="center figure">
<a name="figure-1.3"></a><img src="blockcode-images/turtle_example.png" alt="Figure 1.3 - Example of Turtle code running" title="Figure 1.3 - Example of Turtle code running" />
</div>

<p class="center figcaption">
<small>Figure 1.3 - Example of Turtle code running</small>
</p>

<p>Turtle programming is a style of graphics programming, first popularized by Logo, where you have an imaginary turtle carrying a pen walking on the screen. You can tell the turtle to pick up the pen (stop drawing, but still move), put the pen down (leaving a line everywhere it goes), move forward a number of steps, or turn a number of degrees. Just those commands, combined with looping, can create amazingly intricate images.</p>

<p>In this version of turtle graphics we have a few extra blocks. Technically we don't need both <code>turn right</code> and <code>turn left</code> because you can have one and get the other with negative numbers. Likewise <code>move back</code> can be done with <code>move forward</code> and negative numbers. In this case it felt more balanced to have both.</p>

<p>The image above was formed by putting two loops inside another loop and adding a <code>move forward</code> and <code>turn right</code> to each loop, then playing with the parameters interactively until I liked the image that resulted.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">var</span> PIXEL_RATIO = <span class="ot">window</span>.<span class="fu">devicePixelRatio</span> || <span class="dv">1</span>;
    <span class="kw">var</span> canvasPlaceholder = <span class="ot">document</span>.<span class="fu">querySelector</span>(<span class="st">&#39;.canvas-placeholder&#39;</span>);
    <span class="kw">var</span> canvas = <span class="ot">document</span>.<span class="fu">querySelector</span>(<span class="st">&#39;.canvas&#39;</span>);
    <span class="kw">var</span> script = <span class="ot">document</span>.<span class="fu">querySelector</span>(<span class="st">&#39;.script&#39;</span>);
    <span class="kw">var</span> ctx = <span class="ot">canvas</span>.<span class="fu">getContext</span>(<span class="st">&#39;2d&#39;</span>);
    <span class="kw">var</span> cos = <span class="ot">Math</span>.<span class="fu">cos</span>, sin = <span class="ot">Math</span>.<span class="fu">sin</span>, sqrt = <span class="ot">Math</span>.<span class="fu">sqrt</span>, PI = <span class="ot">Math</span>.<span class="fu">PI</span>;
    <span class="kw">var</span> DEGREE = PI / <span class="dv">180</span>;
    <span class="kw">var</span> WIDTH, HEIGHT, position, direction, visible, pen, color;</code></pre>

<p>The <code>reset()</code> function clears all the state variables to their defaults. If we were to support multiple turtles, these variables would be encapsulated in an object. We also have a utility, <code>deg2rad(deg)</code>, because we work in degrees in the UI, but we draw in radians. Finally, <code>drawTurtle()</code> draws the turtle itself. The default turtle is simply a triangle, but you could override this to draw a more aesthetically-pleasing turtle.</p>

<p>Note that <code>drawTurtle</code> uses the same primitive operations that we define to implement the turtle drawing. Sometimes you don't want to reuse code at different abstraction layers, but when the meaning is clear it can be a big win for code size and performance.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">reset</span>(){
        <span class="fu">recenter</span>();
        direction = <span class="fu">deg2rad</span>(<span class="dv">90</span>); <span class="co">// facing &quot;up&quot;</span>
        visible = <span class="kw">true</span>;
        pen = <span class="kw">true</span>; <span class="co">// when pen is true we draw, otherwise we move without drawing</span>
        color = <span class="st">&#39;black&#39;</span>;
    }

    <span class="kw">function</span> <span class="fu">deg2rad</span>(degrees){ <span class="kw">return</span> DEGREE * degrees; }

    <span class="kw">function</span> <span class="fu">drawTurtle</span>(){
        <span class="kw">var</span> userPen = pen; <span class="co">// save pen state</span>
        <span class="kw">if</span> (visible){
            <span class="fu">penUp</span>(); <span class="fu">_moveForward</span>(<span class="dv">5</span>); <span class="fu">penDown</span>();
            <span class="fu">_turn</span>(-<span class="dv">150</span>); <span class="fu">_moveForward</span>(<span class="dv">12</span>);
            <span class="fu">_turn</span>(-<span class="dv">120</span>); <span class="fu">_moveForward</span>(<span class="dv">12</span>);
            <span class="fu">_turn</span>(-<span class="dv">120</span>); <span class="fu">_moveForward</span>(<span class="dv">12</span>);
            <span class="fu">_turn</span>(<span class="dv">30</span>);
            <span class="fu">penUp</span>(); <span class="fu">_moveForward</span>(-<span class="dv">5</span>);
            <span class="kw">if</span> (userPen){
                <span class="fu">penDown</span>(); <span class="co">// restore pen state</span>
            }
        }
    }</code></pre>

<p>We have a special block to draw a circle with a given radius at the current mouse position. We special-case <code>drawCircle</code> because, while you can certainly draw a circle by repeating <code>MOVE 1 RIGHT 1</code> 360 times, controlling the size of the circle is very difficult that way.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">drawCircle</span>(radius){
        <span class="co">// Math for this is from http://www.mathopenref.com/polygonradius.html</span>
        <span class="kw">var</span> userPen = pen; <span class="co">// save pen state</span>
        <span class="kw">if</span> (visible){
            <span class="fu">penUp</span>(); <span class="fu">_moveForward</span>(-radius); <span class="fu">penDown</span>();
            <span class="fu">_turn</span>(-<span class="dv">90</span>);
            <span class="kw">var</span> steps = <span class="ot">Math</span>.<span class="fu">min</span>(<span class="ot">Math</span>.<span class="fu">max</span>(<span class="dv">6</span>, <span class="ot">Math</span>.<span class="fu">floor</span>(radius / <span class="dv">2</span>)), <span class="dv">360</span>);
            <span class="kw">var</span> theta = <span class="dv">360</span> / steps;
            <span class="kw">var</span> side = radius * <span class="dv">2</span> * <span class="ot">Math</span>.<span class="fu">sin</span>(<span class="ot">Math</span>.<span class="fu">PI</span> / steps);
            <span class="fu">_moveForward</span>(side / <span class="dv">2</span>);
            <span class="kw">for</span> (<span class="kw">var</span> i = <span class="dv">1</span>; i &lt; steps; i++){
                <span class="fu">_turn</span>(theta); <span class="fu">_moveForward</span>(side);
            }
            <span class="fu">_turn</span>(theta); <span class="fu">_moveForward</span>(side / <span class="dv">2</span>);
            <span class="fu">_turn</span>(<span class="dv">90</span>);
            <span class="fu">penUp</span>(); <span class="fu">_moveForward</span>(radius); <span class="fu">penDown</span>();
            <span class="kw">if</span> (userPen){
                <span class="fu">penDown</span>(); <span class="co">// restore pen state</span>
            }
        }
    }</code></pre>

<p>Our main primitive is <code>moveForward</code>, which has to handle some elementary trigonometry and check whether the pen is up or down.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">_moveForward</span>(distance){
        <span class="kw">var</span> start = position;
        position = {
            <span class="dt">x</span>: <span class="fu">cos</span>(direction) * distance * PIXEL_RATIO + <span class="ot">start</span>.<span class="fu">x</span>,
            <span class="dt">y</span>: -<span class="fu">sin</span>(direction) * distance * PIXEL_RATIO + <span class="ot">start</span>.<span class="fu">y</span>
        };
        <span class="kw">if</span> (pen){
            <span class="ot">ctx</span>.<span class="fu">lineStyle</span> = color;
            <span class="ot">ctx</span>.<span class="fu">beginPath</span>();
            <span class="ot">ctx</span>.<span class="fu">moveTo</span>(<span class="ot">start</span>.<span class="fu">x</span>, <span class="ot">start</span>.<span class="fu">y</span>);
            <span class="ot">ctx</span>.<span class="fu">lineTo</span>(<span class="ot">position</span>.<span class="fu">x</span>, <span class="ot">position</span>.<span class="fu">y</span>);
            <span class="ot">ctx</span>.<span class="fu">stroke</span>();
        }
    }</code></pre>

<p>Most of the rest of the turtle commands can be easily defined in terms of what we've built above.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">penUp</span>(){ pen = <span class="kw">false</span>; }
    <span class="kw">function</span> <span class="fu">penDown</span>(){ pen = <span class="kw">true</span>; }
    <span class="kw">function</span> <span class="fu">hideTurtle</span>(){ visible = <span class="kw">false</span>; }
    <span class="kw">function</span> <span class="fu">showTurtle</span>(){ visible = <span class="kw">true</span>; }
    <span class="kw">function</span> <span class="fu">forward</span>(block){ <span class="fu">_moveForward</span>(<span class="ot">Block</span>.<span class="fu">value</span>(block)); }
    <span class="kw">function</span> <span class="fu">back</span>(block){ <span class="fu">_moveForward</span>(-<span class="ot">Block</span>.<span class="fu">value</span>(block)); }
    <span class="kw">function</span> <span class="fu">circle</span>(block){ <span class="fu">drawCircle</span>(<span class="ot">Block</span>.<span class="fu">value</span>(block)); }
    <span class="kw">function</span> <span class="fu">_turn</span>(degrees){ direction += <span class="fu">deg2rad</span>(degrees); }
    <span class="kw">function</span> <span class="fu">left</span>(block){ <span class="fu">_turn</span>(<span class="ot">Block</span>.<span class="fu">value</span>(block)); }
    <span class="kw">function</span> <span class="fu">right</span>(block){ <span class="fu">_turn</span>(-<span class="ot">Block</span>.<span class="fu">value</span>(block)); }
    <span class="kw">function</span> <span class="fu">recenter</span>(){ position = {<span class="dt">x</span>: WIDTH/<span class="dv">2</span>, <span class="dt">y</span>: HEIGHT/<span class="dv">2</span>}; }</code></pre>

<p>When we want a fresh slate, the <code>clear</code> function restores everything back to where we started.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">function</span> <span class="fu">clear</span>(){
        <span class="ot">ctx</span>.<span class="fu">save</span>();
        <span class="ot">ctx</span>.<span class="fu">fillStyle</span> = <span class="st">&#39;white&#39;</span>;
        <span class="ot">ctx</span>.<span class="fu">fillRect</span>(<span class="dv">0</span>,<span class="dv">0</span>,WIDTH,HEIGHT);
        <span class="ot">ctx</span>.<span class="fu">restore</span>();
        <span class="fu">reset</span>();
        <span class="ot">ctx</span>.<span class="fu">moveTo</span>(<span class="ot">position</span>.<span class="fu">x</span>, <span class="ot">position</span>.<span class="fu">y</span>);
    }</code></pre>

<p>When this script first loads and runs, we use our <code>reset</code> and <code>clear</code> to initialize everything and draw the turtle.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="fu">onResize</span>();
    <span class="fu">clear</span>();
    <span class="fu">drawTurtle</span>();</code></pre>

<p>Now we can use the functions above, with the <code>Menu.item</code> function from <code>menu.js</code>, to make blocks for the user to build scripts from. These are dragged into place to make the user's programs.</p>

<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="ot">Menu</span>.<span class="fu">item</span>(<span class="st">&#39;Left&#39;</span>, left, <span class="dv">5</span>, <span class="st">&#39;degrees&#39;</span>);
    <span class="ot">Menu</span>.<span class="fu">item</span>(<span class="st">&#39;Right&#39;</span>, right, <span class="dv">5</span>, <span class="st">&#39;degrees&#39;</span>);
    <span class="ot">Menu</span>.<span class="fu">item</span>(<span class="st">&#39;Forward&#39;</span>, forward, <span class="dv">10</span>, <span class="st">&#39;steps&#39;</span>);
    <span class="ot">Menu</span>.<span class="fu">item</span>(<span class="st">&#39;Back&#39;</span>, back, <span class="dv">10</span>, <span class="st">&#39;steps&#39;</span>);
    <span class="ot">Menu</span>.<span class="fu">item</span>(<span class="st">&#39;Circle&#39;</span>, circle, <span class="dv">20</span>, <span class="st">&#39;radius&#39;</span>);
    <span class="ot">Menu</span>.<span class="fu">item</span>(<span class="st">&#39;Pen up&#39;</span>, penUp);
    <span class="ot">Menu</span>.<span class="fu">item</span>(<span class="st">&#39;Pen down&#39;</span>, penDown);
    <span class="ot">Menu</span>.<span class="fu">item</span>(<span class="st">&#39;Back to center&#39;</span>, recenter);
    <span class="ot">Menu</span>.<span class="fu">item</span>(<span class="st">&#39;Hide turtle&#39;</span>, hideTurtle);
    <span class="ot">Menu</span>.<span class="fu">item</span>(<span class="st">&#39;Show turtle&#39;</span>, showTurtle);</code></pre>

<h2 id="lessons-learned">Lessons Learned</h2>

<h3 id="why-not-use-mvc">Why Not Use MVC?</h3>

<p>Model-View-Controller (MVC) was a good design choice for Smalltalk programs in the '80s and it can work in some variation or other for web apps, but it isn't the right tool for every problem. All the state (the &quot;model&quot; in MVC) is captured by the block elements in a block language anyway, so replicating it into Javascript has little benefit unless there is some other need for the model (if we were editing shared, distributed code, for instance).</p>

<p>An early version of Waterbear went to great lengths to keep the model in JavaScript and sync it with the DOM, until I noticed that more than half the code and 90% of the bugs were due to keeping the model in sync with the DOM. Eliminating the duplication allowed the code to be simpler and more robust, and with all the state on the DOM elements, many bugs could be found simply by looking at the DOM in the developer tools. So in this case there is little benefit to building further separation of MVC than we already have in HTML/CSS/JavaScript.</p>

<h3 id="toy-changes-can-lead-to-real-changes">Toy Changes Can Lead to Real Changes</h3>

<p>Building a small, tightly scoped version of the larger system I work on has been an interesting exercise. Sometimes in a large system there are things you are hesitant to change because they affect too many other things. In a tiny, toy version you can experiment freely and learn things which you can then take back to the larger system. For me, the larger system is Waterbear and this project has had a huge impact on the way Waterbear is structured.</p>

<h4 id="small-experiments-make-failure-ok">Small Experiments Make Failure OK</h4>

<p>Some of the experiments I was able to do with this stripped-down block language were:</p>

<ul>
<li>using HTML5 drag-and-drop,</li>
<li>running blocks directly by iterating through the DOM calling associated functions,</li>
<li>separating the code that runs cleanly from the HTML DOM,</li>
<li>simplified hit testing while dragging,</li>
<li>building our own tiny vector and sprite libraries (for the game blocks), and</li>
<li>&quot;live coding&quot; where the results are shown whenever you change the block script.</li>
</ul>

<p>The thing about experiments is that they do not have to succeed. We tend to gloss over failures and dead ends in our work, where failures are punished instead of treated as important vehicles for learning, but failures are essential if you are going to push forward. While I did get the HTML5 drag-and-drop working, the fact that it isn't supported at all on any mobile browser means it is a non-starter for Waterbear. Separating the code out and running code by iterating through the blocks worked so well that I've already begun bringing those ideas to Waterbear, with excellent improvements in testing and debugging. The simplified hit testing, with some modifications, is also coming back to Waterbear, as are the tiny vector and sprite libraries. Live coding hasn't made it to Waterbear yet, but once the current round of changes stabilizes I may introduce it.</p>

<h4 id="what-are-we-trying-to-build-really">What Are We Trying to Build, Really?</h4>

<p>Building a small version of a bigger system puts a sharp focus on what the important parts really are. Are there bits left in for historical reasons that serve no purpose (or worse, distract from the purpose)? Are there features no-one uses but you have to pay to maintain? Could the user interface be streamlined? All these are great questions to ask while making a tiny version. Drastic changes, like re-organizing the layout, can be made without worrying about the ramifications cascading through a more complex system, and can even guide refactoring the complex system.</p>

<h4 id="a-program-is-a-process-not-a-thing">A Program is a Process, Not a Thing</h4>

<p>There are things I wasn't able to experiment with in the scope of this project that I may use the blockcode codebase to test out in the future. It would be interesting to create &quot;function&quot; blocks which create new blocks out of existing blocks. Implementing undo/redo would be simpler in a constrained environment. Making blocks accept multiple arguments without radically expanding the complexity would be useful. And finding various ways to share block scripts online would bring the webbiness of the tool full circle.</p>
        </div>
      </div>
    </div>
  </body>
</html>